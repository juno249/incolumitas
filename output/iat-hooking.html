<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="/theme/css/style.min.css">
  <link rel="stylesheet" type="text/css" href="/theme/css/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="/theme/css/font-awesome.min.css">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />
<meta name="author" content="Nikolai Tschacher" />
<meta name="description" content="What I just rummaged through my old hard disk and suddenly stumbled across some old C sources from around a year ago when I played with IAT hooking on windows 7. I will not explain much, but I made the bottom code around a year ago (Thus, in 2012) and ..." />
<meta name="keywords" content="C, Hooking, Programming, Security, Windows, Nt, Assembler, Iat">
<meta property="og:site_name" content="Coding, Learning and IT Security"/>
<meta property="og:title" content="IAT hooking"/>
<meta property="og:description" content="What I just rummaged through my old hard disk and suddenly stumbled across some old C sources from around a year ago when I played with IAT hooking on windows 7. I will not explain much, but I made the bottom code around a year ago (Thus, in 2012) and ..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="/iat-hooking.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2013-12-07 11:37:00+01:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="/author/nikolai-tschacher.html">
<meta property="article:section" content="C"/>
<meta property="article:tag" content="C"/>
<meta property="article:tag" content="Hooking"/>
<meta property="article:tag" content="Programming"/>
<meta property="article:tag" content="Security"/>
<meta property="article:tag" content="Windows"/>
<meta property="article:tag" content="Nt"/>
<meta property="article:tag" content="Assembler"/>
<meta property="article:tag" content="Iat"/>
<meta property="og:image" content="">  <title>Coding, Learning and IT Security &ndash; IAT hooking</title>
</head>
<body>
  <aside>
    <div>
      <a href="">
        <img src="/theme/img/profile.png" alt="Coding, Learning and IT Security" title="Coding, Learning and IT Security">
      </a>
      <h1><a href="">Coding, Learning and IT Security</a></h1>
      <p></p>
      <nav>
        <ul class="list">
          <li><a href="/pages/about.html#about">About</a></li>
          <li><a href="/pages/contact.html#contact">Contact</a></li>
          <li><a href="/pages/googlescraper-py.html#googlescraper-py">GoogleScraper.py</a></li>
          <li><a href="/pages/projects.html#projects">Projects</a></li>
          <li><a href="/pages/impressum.html#impressum">Site Notice</a></li>
          <li><a href="/pages/svgcaptcha.html#svgcaptcha">SVGCaptcha</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-twitter" href="https://twitter.com/incolumitas_" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-github" href="https://github.com/NikolaiT" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-rss" href="//incolumitas/feeds/all.atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/1052496/nikolai-tschacher" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
    </nav>

<article>
  <header>
    <h1 id="iat-hooking">IAT hooking</h1>
    <p>Posted on Sa 07 Dezember 2013 in <a href="/category/c.html">C</a></p>
  </header>
  <div>
    <h3>What</h3>
<p>I just rummaged through my old hard disk and suddenly stumbled across
some old C sources from around a year ago when I played with IAT hooking
on windows 7. I will not explain much, but I made the bottom code around
a year ago (Thus, in 2012) and it should be able to hook any code
(depicted as the handler here) into running processes via the IAT. I
suppose the code is not working properly, but it gives a good picture of
how an IAT hooking approach might look like.</p>
<h3><a href="http://www.youtube.com/watch?v=432PZ9787n0">What'll you do?</a></h3>
<p>Hopefully I'll find some time and motivation (or more appropriate:
discipline) to update the little library and finally complete it. Maybe
I will also make it compatible with windows 8, but I assume it's not
really different from windows 7 (Hell I don't know anything about the
windows API)...</p>
<div class="highlight"><pre><span class="cp">#include &quot;main.h&quot;</span>

<span class="cm">/* </span>
<span class="cm"> * Implements a little library to Hook the WinApi on running programs.</span>
<span class="cm"> * Furthermore, the API provides functions too find code caves and little hook templates for the most common scenarios</span>
<span class="cm"> * when we use hooking: Intercept function parameters and monitor output...</span>
<span class="cm"> * Supports both, 32 and 64 bit Windows XP to Windows 7. The code is pretty bloated, because</span>
<span class="cm"> * I intended to catch as many errors as possbible and included some debug stuff. This hooking &#39;library&#39; shall be reliable.</span>
<span class="cm"> * It provides just IAT hooking, no other code injections.</span>
<span class="cm"> */</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">;</span>
    <span class="n">HOOK_CONTEXT</span> <span class="o">*</span><span class="n">pHookContext</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">bSuccess</span><span class="p">;</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">handler</span> <span class="o">=</span>
        <span class="s">&quot;</span><span class="se">\x90\x90\x90\x90\x90\x90\x90\x90</span><span class="s">&quot;</span>
        <span class="s">&quot;</span><span class="se">\x90\x90\x90\x90\x90\x90\x90\x90</span><span class="s">&quot;</span>
        <span class="s">&quot;</span><span class="se">\x90\x90\x90\x90\x90\x90\x90\x90</span><span class="s">&quot;</span><span class="p">;</span>

<span class="cp">#ifdef _WIN64</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] 64 architecture detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[-] Sorry, currently not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef _WIN32</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] 32 architecture detected</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="n">GetCurrentProcessId</span><span class="p">();</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] using current process id as target</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pid</span> <span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Usage: %s PID&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Try to open the specified process */</span>
    <span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span>
    <span class="p">(</span>
        <span class="n">PROCESS_QUERY_INFORMATION</span> <span class="o">|</span>
        <span class="n">PROCESS_VM_OPERATION</span> <span class="o">|</span>
        <span class="n">PROCESS_VM_READ</span> <span class="o">|</span>
        <span class="n">PROCESS_VM_WRITE</span> <span class="o">|</span>
        <span class="n">PROCESS_SET_QUOTA</span><span class="p">,</span>
        <span class="n">FALSE</span><span class="p">,</span>
        <span class="n">pid</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hProcess</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[!] OpenProcess() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] Remote Process with PID=%d opened</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Hook shit */</span>
    <span class="n">pHookContext</span> <span class="o">=</span> <span class="n">HookFunction</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="s">&quot;USER32.DLL&quot;</span><span class="p">,</span>
        <span class="s">&quot;MessageBoxA&quot;</span><span class="p">,</span>
        <span class="n">handler</span><span class="p">,</span>
        <span class="n">strlen</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pHookContext</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[!] Hooking failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] hooked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>


    <span class="n">Sleep</span><span class="p">(</span><span class="mi">50000</span><span class="p">);</span> <span class="c1">// Sleep 60 seconds. Try now the new behaviour of the function :)</span>

    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">ReleaseHook</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">pHookContext</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[!] Release Hook failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] Hook released</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>

    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hProcess</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// =============================================================================================</span>

<span class="n">DWORD</span>
<span class="nf">FindRemotePEB</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">HMODULE</span> <span class="n">hNTDll</span><span class="p">;</span>
    <span class="n">FARPROC</span> <span class="n">fpNtQueryInformationProcess</span><span class="p">;</span>
    <span class="n">NTSTATUS</span> <span class="n">status</span><span class="p">;</span>
    <span class="n">PROCESS_BASIC_INFORMATION</span> <span class="n">procBasicInformation</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">returnLength</span><span class="p">;</span>

    <span class="n">hNTDll</span> <span class="o">=</span> <span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">&quot;ntdll&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hNTDll</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;LoadLibraryA() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">fpNtQueryInformationProcess</span> <span class="o">=</span> <span class="n">GetProcAddress</span>
    <span class="p">(</span>
        <span class="n">hNTDll</span><span class="p">,</span>
        <span class="s">&quot;NtQueryInformationProcess&quot;</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fpNtQueryInformationProcess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;GetProcAddress() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">NtQueryInformationProcess</span> <span class="n">ntQueryInformationProcess</span> <span class="o">=</span> 
        <span class="p">(</span><span class="n">NtQueryInformationProcess</span><span class="p">)</span><span class="n">fpNtQueryInformationProcess</span><span class="p">;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">ntQueryInformationProcess</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="c1">// ProcessBasicInformation</span>
        <span class="o">&amp;</span><span class="n">procBasicInformation</span><span class="p">,</span>
        <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESS_BASIC_INFORMATION</span><span class="p">),</span>
        <span class="o">&amp;</span><span class="n">returnLength</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;NtQueryInformationProcess() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="n">procBasicInformation</span><span class="p">.</span><span class="n">PebBaseAddress</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// =============================================================================================</span>

<span class="cm">/* Get&#39;s the PEB of the own process */</span>
<span class="n">DWORD</span> 
<span class="nf">FindOwnPEB</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">pebAddr</span><span class="p">;</span>

<span class="cp">#ifdef _WIN32</span>
    <span class="n">_asm</span> 
    <span class="p">{</span>
        <span class="n">push</span> <span class="n">eax</span> <span class="c1">// push the values of the register eax on the stack</span>
        <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="nl">FS</span><span class="p">:[</span><span class="mh">0x30</span><span class="p">]</span> <span class="c1">// store the values ad address FS:[0x30] in eax</span>
        <span class="n">mov</span> <span class="p">[</span><span class="n">pebAddr</span><span class="p">],</span> <span class="n">eax</span> <span class="c1">// store the values of eax in the variable pebAddr</span>
        <span class="n">pop</span> <span class="n">eax</span> <span class="c1">// remake initial eax value</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef _WIN64</span>
    <span class="n">_asm</span>
    <span class="p">{</span>
        <span class="n">push</span> <span class="n">rax</span>
        <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="nl">FS</span><span class="p">:[</span><span class="mh">0x30</span><span class="p">]</span>
        <span class="n">mov</span> <span class="p">[</span><span class="n">pebAddr</span><span class="p">],</span> <span class="n">rax</span>
        <span class="n">pop</span> <span class="n">rax</span>
    <span class="p">}</span>
<span class="cp">#endif</span>

    <span class="k">return</span> <span class="n">pebAddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// =============================================================================================</span>

<span class="n">PIMAGE_DATA_DIRECTORY</span>
<span class="nf">ReadRemoteDataDirectoryRVA</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">LPCVOID</span> <span class="n">lpImageBaseAddress</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PIMAGE_NT_HEADERS32</span> <span class="n">pNTHeaders</span><span class="p">;</span>
    <span class="n">PIMAGE_DATA_DIRECTORY</span> <span class="n">dataDir</span><span class="p">;</span>
    <span class="n">BYTE</span><span class="o">*</span> <span class="n">lpBuffer</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;No valid DATA_DIRECTORY directory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">lpBuffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">));</span>
    <span class="n">ZeroMemory</span><span class="p">(</span><span class="n">lpBuffer</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lpBuffer</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;malloc() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">BOOL</span> <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">VirtualProtectEx</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="p">(</span><span class="n">PVOID</span><span class="p">)</span><span class="n">lpImageBaseAddress</span><span class="p">,</span>
        <span class="n">BUFFER_SIZE</span><span class="p">,</span>
        <span class="n">PAGE_EXECUTE_READ</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">oldProtect</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;VirtualProtectEx() failed in ReadRemoteDataDirectoryRVA() with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">ReadProcessMemory</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpImageBaseAddress</span><span class="p">,</span>
        <span class="n">lpBuffer</span><span class="p">,</span>
        <span class="n">BUFFER_SIZE</span><span class="p">,</span>
        <span class="mi">0</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ReadProcessMemory() failed in ReadRemoteDataDirectoryRVA() with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">PIMAGE_DOS_HEADER</span> <span class="n">pDOSHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)</span><span class="n">lpBuffer</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pDOSHeader</span><span class="o">-&gt;</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="mh">0x5a4d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Invalid DOS header. e_magic is not  0x5a4d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pNTHeaders</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_NT_HEADERS32</span><span class="p">)(</span><span class="n">lpBuffer</span> <span class="o">+</span> <span class="n">pDOSHeader</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pNTHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">Magic</span> <span class="o">!=</span> <span class="mh">0x10b</span> <span class="o">&amp;&amp;</span> <span class="c1">// PE32</span>
        <span class="n">pNTHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">Magic</span> <span class="o">!=</span> <span class="mh">0x20b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// PE32+</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Invalid Magic in OptionalHeader</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] Detected %s architecture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
             <span class="n">pNTHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">Magic</span> <span class="o">==</span> <span class="mh">0x10b</span> <span class="o">?</span> <span class="s">&quot;PE32&quot;</span> <span class="o">:</span> <span class="s">&quot;PE32+&quot;</span><span class="p">);</span>

    <span class="n">dataDir</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pNTHeaders</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">DataDirectory</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">dataDir</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// =============================================================================================</span>

<span class="cm">/*</span>
<span class="cm"> * Caller has to free the returned LOADED_IMAGE structure.</span>
<span class="cm"> */</span>
<span class="n">PLOADED_IMAGE</span> <span class="nf">ReadRemoteImage</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpImageBaseAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PCHAR</span> <span class="n">lpBuffer</span><span class="p">;</span>
    <span class="n">PIMAGE_DOS_HEADER</span> <span class="n">pDOSHeader</span><span class="p">;</span>
    <span class="n">PLOADED_IMAGE</span> <span class="n">pImage</span><span class="p">;</span>

    <span class="n">BOOL</span> <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">RetReadProcessMemory</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">lpBuffer</span><span class="p">,</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpImageBaseAddress</span><span class="p">,</span>
        <span class="n">BUFFER_SIZE</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory() failed in ReadRemoteImage() with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pDOSHeader</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_DOS_HEADER</span><span class="p">)</span><span class="n">lpBuffer</span><span class="p">;</span>

    <span class="n">pImage</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">LOADED_IMAGE</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pImage</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;malloc() failed in ReadRemoteImage() with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">FileHeader</span> <span class="o">=</span> 
        <span class="p">(</span><span class="n">PIMAGE_NT_HEADERS32</span><span class="p">)(</span><span class="n">lpBuffer</span> <span class="o">+</span> <span class="n">pDOSHeader</span><span class="o">-&gt;</span><span class="n">e_lfanew</span><span class="p">);</span>

    <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">NumberOfSections</span> <span class="o">=</span> 
        <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="p">.</span><span class="n">NumberOfSections</span><span class="p">;</span>

    <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">Sections</span> <span class="o">=</span> 
        <span class="p">(</span><span class="n">PIMAGE_SECTION_HEADER</span><span class="p">)(</span><span class="n">lpBuffer</span> <span class="o">+</span> <span class="n">pDOSHeader</span><span class="o">-&gt;</span><span class="n">e_lfanew</span> <span class="o">+</span> 
        <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_NT_HEADERS32</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pDOSHeader</span><span class="o">-&gt;</span><span class="n">e_magic</span> <span class="o">!=</span> <span class="mh">0x5a4d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Invalid DOS header. e_magic is not  0x5a4d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pImage</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">Magic</span> <span class="o">!=</span> <span class="mh">0x10b</span> <span class="o">&amp;&amp;</span> <span class="c1">// PE32</span>
        <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">Magic</span> <span class="o">!=</span> <span class="mh">0x20b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// PE32+</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Invalid Magic in OptionalHeader</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] Detected %s architecture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
             <span class="n">pImage</span><span class="o">-&gt;</span><span class="n">FileHeader</span><span class="o">-&gt;</span><span class="n">OptionalHeader</span><span class="p">.</span><span class="n">Magic</span> <span class="o">==</span> <span class="mh">0x10b</span> <span class="o">?</span> <span class="s">&quot;PE32&quot;</span> <span class="o">:</span> <span class="s">&quot;PE32+&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">pImage</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// =============================================================================================</span>

<span class="n">PIMAGE_SECTION_HEADER</span> <span class="nf">FindSectionHeaderByName</span><span class="p">(</span><span class="n">PIMAGE_SECTION_HEADER</span> <span class="n">pHeaders</span><span class="p">,</span> 
                                              <span class="n">DWORD</span> <span class="n">dwNumberOfSections</span><span class="p">,</span> <span class="n">LPCTSTR</span> <span class="n">pSectionName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PIMAGE_SECTION_HEADER</span> <span class="n">pHeaderMatch</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">DWORD</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dwNumberOfSections</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PIMAGE_SECTION_HEADER</span> <span class="n">pHeader</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pHeaders</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">_stricmp</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pHeader</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">pSectionName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pHeaderMatch</span> <span class="o">=</span> <span class="n">pHeader</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">pHeaderMatch</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finds a code cave in the .text section of the DLL. If this function is unable to </span>
<span class="cm"> * find a code cave at least minimalSize bytes long, it fails and so will the whole </span>
<span class="cm"> * hooking attempt. By failure, will return 0.</span>
<span class="cm"> */</span>
<span class="n">DWORD</span>
<span class="nf">FindRemoteCodeCave</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpImageBaseAddress</span><span class="p">,</span> <span class="n">LPCTSTR</span> <span class="n">libName</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">minimalCodeCaveSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwHandlerAddress</span><span class="p">;</span>
    <span class="n">PLOADED_IMAGE</span> <span class="n">pLoadedImage</span><span class="p">;</span>
    <span class="n">PIMAGE_SECTION_HEADER</span> <span class="n">pCodeSectionHeader</span><span class="p">;</span>

    <span class="n">pLoadedImage</span> <span class="o">=</span>  <span class="n">ReadRemoteImage</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpImageBaseAddress</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pLoadedImage</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ReadRemoteImage failed...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pCodeSectionHeader</span> <span class="o">=</span> <span class="n">FindSectionHeaderByName</span>
    <span class="p">(</span>
        <span class="n">pLoadedImage</span><span class="o">-&gt;</span><span class="n">Sections</span><span class="p">,</span>
        <span class="n">pLoadedImage</span><span class="o">-&gt;</span><span class="n">NumberOfSections</span><span class="p">,</span>
        <span class="s">&quot;.text&quot;</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pCodeSectionHeader</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t locate the .text section. Maybe it&#39;s named differently</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * Because there is a essential difference between PE Files in memory and on disk, </span>
<span class="cm">     * we might observe a phenomenon due to the different file alignment which comes handy</span>
<span class="cm">     * when we are in need to write our shell code to a process:</span>
<span class="cm">     */</span>
    <span class="n">dwHandlerAddress</span> <span class="o">=</span>  <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="n">lpImageBaseAddress</span> <span class="o">+</span> 
                        <span class="n">pCodeSectionHeader</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span> <span class="o">+</span> 
                        <span class="n">pCodeSectionHeader</span><span class="o">-&gt;</span><span class="n">SizeOfRawData</span> <span class="o">-</span> <span class="n">minimalCodeCaveSize</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">dwHandlerAddress</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// =============================================================================================</span>

<span class="n">BOOL</span>
<span class="nf">PrintImportDirectory</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">PIMAGE_DATA_DIRECTORY</span> <span class="n">imageImportDirectory</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">imageBase</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PCHAR</span> <span class="n">buf</span><span class="p">,</span> <span class="n">dllNameBuf</span><span class="p">;</span>
    <span class="n">PCHAR</span> <span class="n">lpFunctionNameBuf</span><span class="p">;</span>
    <span class="n">PIMAGE_IMPORT_DESCRIPTOR</span> <span class="n">pImageImportDescriptor</span><span class="p">;</span>
    <span class="n">IMAGE_THUNK_DATA</span> <span class="n">ThunkDataINT</span><span class="p">,</span> <span class="n">ThunkDataIAT</span><span class="p">;</span>
    <span class="n">PIMAGE_IMPORT_BY_NAME</span> <span class="n">pImageImportByName</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">functionOffset</span><span class="p">,</span> <span class="n">firstRVA</span><span class="p">,</span> <span class="n">counter</span><span class="p">;</span>

    <span class="n">firstRVA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">BOOL</span> <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">RetReadProcessMemory</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">imageImportDirectory</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">),</span>
        <span class="mi">50</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_IMPORT_DESCRIPTOR</span><span class="p">)</span> <span class="c1">// not more than 50 dll&#39;s in a module :)</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(buf) in PrintImportDirectory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bSuccess</span> <span class="o">!=</span> <span class="n">MEM_ALLOC_FAIL_CODE</span><span class="p">)</span>
            <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pImageImportDescriptor</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_IMPORT_DESCRIPTOR</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="cm">/* pImageImportDescriptor[index].Characteristics is </span>
<span class="cm">     * set to 0 to indicate the end of the array of IMAGE_IMPORT_DESCRIPTORs.</span>
<span class="cm">     */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">Characteristics</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* Read the memory of the DLLName:) */</span>
        <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">RetReadProcessMemory</span>
        <span class="p">(</span>
            <span class="o">&amp;</span><span class="n">dllNameBuf</span><span class="p">,</span>
            <span class="n">hProcess</span><span class="p">,</span>
            <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">),</span>
            <span class="n">BUFFER_SIZE_SMALL</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(dllNameBuf) in PrintImportDirectory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bSuccess</span> <span class="o">!=</span> <span class="n">MEM_ALLOC_FAIL_CODE</span><span class="p">)</span>
                <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dllNameBuf</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Dll </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> found&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">dllNameBuf</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">OriginalFirstThunk is 0x%x&quot;</span><span class="p">,</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">OriginalFirstThunk</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">FirstThunk is 0x%x&quot;</span><span class="p">,</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">FirstThunk</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">TimeDateStamp is 0x%x&quot;</span><span class="p">,</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">TimeDateStamp</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">ForwarderChain is 0x%x&quot;</span><span class="p">,</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">ForwarderChain</span><span class="p">);</span>

        <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dllNameBuf</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n\t</span><span class="s">FUNCTION-NAME : FUNCTION-ADDRESS : ADDRESS OF FUNCTION ADDRESS&quot;</span><span class="p">);</span>
        <span class="n">functionOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">FirstThunk</span><span class="p">);</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Read the memory of the INT thunk table element :) */</span>
            <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">ReadProcessMemory</span>
            <span class="p">(</span>
                <span class="n">hProcess</span><span class="p">,</span>
                <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">OriginalFirstThunk</span> <span class="o">+</span> <span class="n">counter</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">)),</span>
                <span class="o">&amp;</span><span class="n">ThunkDataINT</span><span class="p">,</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_THUNK_DATA</span><span class="p">),</span>
                <span class="nb">NULL</span>
            <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(lpThunkINTBuffer) in PrintImportDirectory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* Read the memory of the IAT thunk table element :) */</span>
            <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">ReadProcessMemory</span>
            <span class="p">(</span>
                <span class="n">hProcess</span><span class="p">,</span>
                <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">FirstThunk</span> <span class="o">+</span> <span class="n">counter</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">)),</span>
                <span class="o">&amp;</span><span class="n">ThunkDataIAT</span><span class="p">,</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_THUNK_DATA</span><span class="p">),</span>
                <span class="nb">NULL</span>
            <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(lpThunkINTBuffer) in PrintImportDirectory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* Check if we reached the end of the array */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ThunkDataIAT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">firstRVA</span> <span class="o">=</span> <span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span><span class="p">;</span>

            <span class="cm">/* </span>
<span class="cm">             * Huge problem here is that the RVA&#39;s pointing to the names of the function in the IAT</span>
<span class="cm">             * are not in a ascending order. The RVA&#39;s may even be broken (yeah the linkers are bad^^)</span>
<span class="cm">             * and we may get invalid indices. How can we figure out that we do have a valid RVA in  </span>
<span class="cm">             * pThunkDataINT-&gt;u1.AddressOfData ?!</span>
<span class="cm">             * There are just bad solutions (or lazyness when it comes to </span>
<span class="cm">             * heuristic fine tuning, so we apply a heuristic function on all RVA&#39;s of the </span>
<span class="cm">             * IMAGE_THUNK_DATA INT array to ignore RVA&#39;s which have a absolute difference from </span>
<span class="cm">             * more than 0x5000 bytes to the first RVA. What happens if the first RVA is a invalid </span>
<span class="cm">             * one? We&#39;re screwed, but at least the other is able to locate the problem quickly.</span>
<span class="cm">             */</span>
            <span class="c1">// test if we stumbled upon a suspicious RVA (after hoping that the first is not :/)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span> <span class="o">-</span> <span class="n">firstRVA</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x5000</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">RVA in INT-&gt;u1.AddressOfData might be broken (%x) - ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                    <span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

                <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">RetReadProcessMemory</span>
                <span class="p">(</span>
                    <span class="o">&amp;</span><span class="n">lpFunctionNameBuf</span><span class="p">,</span>
                    <span class="n">hProcess</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span><span class="p">),</span>
                    <span class="n">BUFFER_SIZE_SMALL</span>
                <span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(lpFunctionNameBuf) in HookFunction() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">bSuccess</span> <span class="o">!=</span> <span class="n">MEM_ALLOC_FAIL_CODE</span><span class="p">)</span>
                        <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpFunctionNameBuf</span><span class="p">);</span>
                    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">pImageImportByName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_IMPORT_BY_NAME</span><span class="p">)</span><span class="n">lpFunctionNameBuf</span><span class="p">;</span>

                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">%s: 0x%x : 0x%x&quot;</span><span class="p">,</span> <span class="n">pImageImportByName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span>
                                <span class="n">ThunkDataIAT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span><span class="p">,</span> <span class="n">functionOffset</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">functionOffset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">);</span>
            <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">pImageImportDescriptor</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* We can free up now the allocated buffer */</span>
    <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// =============================================================================================</span>

<span class="cm">/* </span>
<span class="cm"> * Looks up the function address in the IAT with LibName and funcName and </span>
<span class="cm"> * patches the pointer to the value in redirection. If the function succeeds, it will</span>
<span class="cm"> * return the OLD function pointer, so you can save it to restore the default behaviour. If </span>
<span class="cm"> * HookFunction fails, it will return FALSE(0).</span>
<span class="cm"> */</span>
<span class="n">DWORD</span> <span class="nf">PatchIAT</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">PIMAGE_DATA_DIRECTORY</span> <span class="n">imageImportDirectory</span><span class="p">,</span>
     <span class="n">DWORD</span> <span class="n">imageBase</span><span class="p">,</span> <span class="n">LPCTSTR</span> <span class="n">libName</span><span class="p">,</span> <span class="n">LPCTSTR</span> <span class="n">funcName</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">redirectionAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PCHAR</span> <span class="n">buf</span><span class="p">,</span> <span class="n">dllNameBuf</span><span class="p">;</span>
    <span class="n">PCHAR</span> <span class="n">lpFunctionNameBuf</span><span class="p">;</span>
    <span class="n">PIMAGE_IMPORT_DESCRIPTOR</span> <span class="n">pImageImportDescriptor</span><span class="p">;</span>
    <span class="n">IMAGE_THUNK_DATA</span> <span class="n">ThunkDataINT</span><span class="p">,</span> <span class="n">ThunkDataIAT</span><span class="p">;</span>
    <span class="n">PIMAGE_IMPORT_BY_NAME</span> <span class="n">pImageImportByName</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">functionOffset</span><span class="p">,</span> <span class="n">firstRVA</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">functionMemValue</span><span class="p">;</span>

    <span class="n">firstRVA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">functionMemValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">BOOL</span> <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">RetReadProcessMemory</span>
    <span class="p">(</span>
        <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">imageImportDirectory</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">),</span>
        <span class="mi">50</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_IMPORT_DESCRIPTOR</span><span class="p">)</span> <span class="c1">// not more than 50 dll&#39;s in a module :)</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(buf) in PrintImportDirectory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bSuccess</span> <span class="o">!=</span> <span class="n">MEM_ALLOC_FAIL_CODE</span><span class="p">)</span>
            <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pImageImportDescriptor</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_IMPORT_DESCRIPTOR</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="cm">/* </span>
<span class="cm">     * pImageImportDescriptor[index].Characteristics is </span>
<span class="cm">     * set to 0 to indicate the end of the array of IMAGE_IMPORT_DESCRIPTORs.</span>
<span class="cm">     */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">Characteristics</span><span class="p">)</span> <span class="p">{</span>

        <span class="cm">/* Read the memory of the DLLName:) */</span>
        <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">RetReadProcessMemory</span>
        <span class="p">(</span>
            <span class="o">&amp;</span><span class="n">dllNameBuf</span><span class="p">,</span>
            <span class="n">hProcess</span><span class="p">,</span>
            <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">),</span>
            <span class="n">BUFFER_SIZE_SMALL</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(dllNameBuf) in PrintImportDirectory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bSuccess</span> <span class="o">!=</span> <span class="n">MEM_ALLOC_FAIL_CODE</span><span class="p">)</span>
                <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dllNameBuf</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">functionOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">FirstThunk</span><span class="p">);</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* Read the memory of the INT thunk table element :) */</span>
            <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">ReadProcessMemory</span>
            <span class="p">(</span>
                <span class="n">hProcess</span><span class="p">,</span>
                <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">OriginalFirstThunk</span> <span class="o">+</span> <span class="n">counter</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">)),</span>
                <span class="o">&amp;</span><span class="n">ThunkDataINT</span><span class="p">,</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_THUNK_DATA</span><span class="p">),</span>
                <span class="nb">NULL</span>
            <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(lpThunkINTBuffer) in PrintImportDirectory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* Read the memory of the IAT thunk table element :) */</span>
            <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">ReadProcessMemory</span>
            <span class="p">(</span>
                <span class="n">hProcess</span><span class="p">,</span>
                <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">pImageImportDescriptor</span><span class="o">-&gt;</span><span class="n">FirstThunk</span> <span class="o">+</span> <span class="n">counter</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">)),</span>
                <span class="o">&amp;</span><span class="n">ThunkDataIAT</span><span class="p">,</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">IMAGE_THUNK_DATA</span><span class="p">),</span>
                <span class="nb">NULL</span>
            <span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(lpThunkINTBuffer) in PrintImportDirectory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="cm">/* Check if we reached the end of the array */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ThunkDataIAT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">firstRVA</span> <span class="o">=</span> <span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span><span class="p">;</span>

            <span class="cm">/* </span>
<span class="cm">             * Huge problem here is that the RVA&#39;s pointing to the names of the function in the IAT</span>
<span class="cm">             * are not in a ascending order. The RVA&#39;s may even be broken (yeah the linkers are bad^^)</span>
<span class="cm">             * and we may get invalid indices. How can we figure out that we do have a valid RVA in  </span>
<span class="cm">             * pThunkDataINT-&gt;u1.AddressOfData ?!</span>
<span class="cm">             * There are just bad solutions (or lazyness when it comes to </span>
<span class="cm">             * heuristic fine tuning, so we apply a heuristic function on all RVA&#39;s of the </span>
<span class="cm">             * IMAGE_THUNK_DATA INT array to ignore RVA&#39;s which have a absolute difference from </span>
<span class="cm">             * more than 0x5000 bytes to the first RVA. What happens if the first RVA is a invalid </span>
<span class="cm">             * one? We&#39;re screwed, but at least the other is able to locate the problem quickly.</span>
<span class="cm">             */</span>
            <span class="c1">// test if we stumbled upon a suspicious RVA (after hoping that the first is not :/)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span> <span class="o">-</span> <span class="n">firstRVA</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x5000</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">RVA in INT-&gt;u1.AddressOfData might be broken (%x) - ignoring</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                    <span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

                <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">RetReadProcessMemory</span>
                <span class="p">(</span>
                    <span class="o">&amp;</span><span class="n">lpFunctionNameBuf</span><span class="p">,</span>
                    <span class="n">hProcess</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">PVOID</span><span class="p">)(</span><span class="n">imageBase</span> <span class="o">+</span> <span class="n">ThunkDataINT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">AddressOfData</span><span class="p">),</span>
                    <span class="n">BUFFER_SIZE_SMALL</span>
                <span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetReadProcessMemory(lpFunctionNameBuf) in HookFunction() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">bSuccess</span> <span class="o">!=</span> <span class="n">MEM_ALLOC_FAIL_CODE</span><span class="p">)</span>
                        <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpFunctionNameBuf</span><span class="p">);</span>
                    <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">pImageImportByName</span> <span class="o">=</span> <span class="p">(</span><span class="n">PIMAGE_IMPORT_BY_NAME</span><span class="p">)</span><span class="n">lpFunctionNameBuf</span><span class="p">;</span>

                <span class="cm">/* When we are in the whished IAT entry, we write to the process the new value of the function pointer */</span>
                <span class="k">if</span> 
                <span class="p">(</span>
                    <span class="n">_stricmp</span><span class="p">(</span><span class="n">pImageImportByName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">funcName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
                    <span class="n">_stricmp</span><span class="p">(</span><span class="n">dllNameBuf</span><span class="p">,</span> <span class="n">libName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="p">)</span> <span class="p">{</span>
                    <span class="n">functionMemValue</span> <span class="o">=</span> <span class="n">ThunkDataIAT</span><span class="p">.</span><span class="n">u1</span><span class="p">.</span><span class="n">Function</span><span class="p">;</span> <span class="cm">/* save because the struct will be freed up*/</span>

                    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">RetWriteProcessMemory</span>
                    <span class="p">(</span>
                        <span class="n">hProcess</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">functionOffset</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">LPCVOID</span><span class="p">)</span><span class="o">&amp;</span><span class="n">redirectionAddress</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">SIZE_T</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">redirectionAddress</span><span class="p">)</span>
                    <span class="p">);</span>

                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;RetWriteProcessMemory() in HookFunction() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">bSuccess</span> <span class="o">!=</span> <span class="n">MEM_ALLOC_FAIL_CODE</span><span class="p">)</span>
                            <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpFunctionNameBuf</span><span class="p">);</span>
                        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;[i] Patched the IAT API %s in DLL %s at address 0x%x :)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                                             <span class="n">pImageImportByName</span><span class="o">-&gt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">dllNameBuf</span><span class="p">,</span> <span class="n">functionOffset</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span> <span class="cm">/* break the while loop because we updated the IAT*/</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">functionOffset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PVOID</span><span class="p">);</span>
            <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* have we just been to the searched DLL? Assumes that Dll-Names in the IAT are uniqe */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_stricmp</span><span class="p">(</span><span class="n">dllNameBuf</span><span class="p">,</span> <span class="n">libName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//free(&amp;dllNameBuf);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pImageImportDescriptor</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* We can free up now the allocated buffer */</span>
    <span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">functionMemValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// =============================================================================================</span>

<span class="cm">/*</span>
<span class="cm"> * Does the actual hooking. Finds a code cave in the .text section of the </span>
<span class="cm"> * DLL which exports the function specified by funcName. It writes the handler into</span>
<span class="cm"> * the code cave. The sanity of the handler is not a problem of this library.</span>
<span class="cm"> */</span>
<span class="n">HOOK_CONTEXT</span> <span class="o">*</span>
<span class="nf">HookFunction</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">LPCTSTR</span> <span class="n">libName</span><span class="p">,</span> <span class="n">LPCTSTR</span> <span class="n">funcName</span><span class="p">,</span> <span class="n">PVOID</span> <span class="n">handlerBuf</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">handlerSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">pPEP</span><span class="p">,</span> <span class="n">oldFunctionPointer</span><span class="p">,</span> <span class="n">pHandler</span><span class="p">;</span>
    <span class="n">SIZE_T</span> <span class="n">nBytesWritten</span><span class="p">;</span>
    <span class="n">PIMAGE_DATA_DIRECTORY</span> <span class="n">imageImportDirectory</span><span class="p">;</span>
    <span class="n">BOOL</span> <span class="n">bSuccess</span><span class="p">;</span>
    <span class="n">HOOK_CONTEXT</span> <span class="o">*</span><span class="n">pHookContext</span><span class="p">;</span>

    <span class="n">pHookContext</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HOOK_CONTEXT</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pHookContext</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;malloc in HookFunction() failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Locate the Process Environment Block */</span>
    <span class="n">pPEP</span> <span class="o">=</span> <span class="n">FindRemotePEB</span><span class="p">(</span><span class="n">hProcess</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pPEP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[!] FindRemotePEB() failed...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] Remote PEB found: 0x%x. ImageBase address is 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                             <span class="n">pPEP</span><span class="p">,</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)((</span><span class="n">PPEB</span><span class="p">)</span><span class="n">pPEP</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ImageBaseAddress</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Read the RVA to the ImageImportDirectory */</span>
    <span class="n">imageImportDirectory</span> <span class="o">=</span> <span class="n">ReadRemoteDataDirectoryRVA</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span>
                                <span class="p">(</span><span class="n">LPCVOID</span><span class="p">)((</span><span class="n">PPEB</span><span class="p">)</span><span class="n">pPEP</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ImageBaseAddress</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">imageImportDirectory</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[!] ReadRemoteDataDirectoryRV() failed...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] Remote Image Parsed. Virtual Address of RemoteDataDirectory: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                                                         <span class="n">imageImportDirectory</span><span class="o">-&gt;</span><span class="n">VirtualAddress</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Find a code cave where to write the handler */</span>
    <span class="n">pHandler</span> <span class="o">=</span> <span class="n">FindRemoteCodeCave</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="p">((</span><span class="n">PPEB</span><span class="p">)</span><span class="n">pPEP</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ImageBaseAddress</span><span class="p">,</span>
        <span class="n">libName</span><span class="p">,</span>
        <span class="n">handlerSize</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pHandler</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[!] Cannot find code cave in remote image...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] Code cave found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="cm">/* Write the shell code into the code cave :) */</span>
    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">WriteProcessMemory</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">pHandler</span><span class="p">,</span>
        <span class="p">(</span><span class="n">LPCVOID</span><span class="p">)</span><span class="n">handlerBuf</span><span class="p">,</span>
        <span class="n">handlerSize</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">nBytesWritten</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[!] Couldn&#39;t write shell code. Wrote %d bytes instead of %d...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                                                                     <span class="n">nBytesWritten</span><span class="p">,</span> <span class="n">handlerSize</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[i] Handler written to address 0x%x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pHandler</span><span class="p">);</span>


    <span class="cm">/* Patch the IAT with a pointer to the handler */</span>
    <span class="n">pHookContext</span><span class="o">-&gt;</span><span class="n">oldFuncPointer</span> <span class="o">=</span> <span class="n">PatchIAT</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">imageImportDirectory</span><span class="p">,</span>
        <span class="p">(</span><span class="n">DWORD</span><span class="p">)((</span><span class="n">PPEB</span><span class="p">)</span><span class="n">pPEP</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ImageBaseAddress</span><span class="p">,</span>
        <span class="n">libName</span><span class="p">,</span>
        <span class="n">funcName</span><span class="p">,</span>
        <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="n">pHandler</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pHookContext</span><span class="o">-&gt;</span><span class="n">oldFuncPointer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[!] The specified API %s couldn&#39;t be located in the IAT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">funcName</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* The hook should be sharp by now :) */</span>

    <span class="c1">//pHookContext-&gt;pOldFuncPointer =</span>

    <span class="k">return</span> <span class="n">pHookContext</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">BOOL</span>
<span class="nf">ReleaseHook</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">HOOK_CONTEXT</span> <span class="o">*</span><span class="n">pHookContext</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BOOL</span> <span class="n">bSuccess</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* </span>
<span class="cm"> * Caller has to pass a pointer. Caller  has to free() then the mem allocated here</span>
<span class="cm"> * buf is a pointer to a pointer. Otherwise we loose the mem. This is C magic... :/ </span>
<span class="cm"> */</span>
<span class="c1">// =============================================================================================</span>
<span class="n">BOOL</span>
<span class="nf">RetReadProcessMemory</span><span class="p">(</span><span class="n">OUT</span> <span class="n">PCHAR</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpBaseAddress</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">sizeBuf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BOOL</span> <span class="n">bSuccess</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">,</span> <span class="n">dummy</span><span class="p">;</span>
    <span class="n">SIZE_T</span> <span class="n">numBytesRead</span><span class="p">;</span>


    <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">sizeBuf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CHAR</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;calloc() in RetReadProcessMemory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="mh">0x666</span><span class="p">;</span> <span class="c1">// Little hack here</span>
    <span class="p">}</span>

    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">VirtualProtectEx</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpBaseAddress</span><span class="p">,</span>
        <span class="n">sizeBuf</span><span class="p">,</span>
        <span class="n">PAGE_READONLY</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">oldProtect</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;VirtualProtectEx() in RetReadProcessMemory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Read finally the process memory */</span>
    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">ReadProcessMemory</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpBaseAddress</span><span class="p">,</span>
        <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
        <span class="n">sizeBuf</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">numBytesRead</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;ReadProcessMemory() in RetReadProcessMemory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Restore old memory protection constants */</span>
    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">VirtualProtectEx</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpBaseAddress</span><span class="p">,</span>
        <span class="n">sizeBuf</span><span class="p">,</span>
        <span class="n">oldProtect</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">dummy</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;VirtualProtectEx(RESTORING) in RetReadProcessMemory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// =============================================================================================</span>

<span class="n">BOOL</span>
<span class="nf">RetWriteProcessMemory</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hProcess</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpBaseAddress</span><span class="p">,</span> <span class="n">LPCVOID</span> <span class="n">lpBuffer</span><span class="p">,</span> <span class="n">SIZE_T</span> <span class="n">nSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BOOL</span> <span class="n">bSuccess</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">oldProtect</span><span class="p">,</span> <span class="n">dummy</span><span class="p">;</span>
    <span class="n">SIZE_T</span> <span class="n">numBytesWritten</span><span class="p">;</span>

    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">VirtualProtectEx</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpBaseAddress</span><span class="p">,</span>
        <span class="n">nSize</span><span class="p">,</span>
        <span class="n">PAGE_READWRITE</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">oldProtect</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;VirtualProtectEx() in RetWriteProcessMemory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">WriteProcessMemory</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpBaseAddress</span><span class="p">,</span>
        <span class="n">lpBuffer</span><span class="p">,</span>
        <span class="n">nSize</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">numBytesWritten</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;WriteProcessMemory in WriteProcessMemory() failed with %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Restore old memory protection constants */</span>
    <span class="n">bSuccess</span> <span class="o">=</span> <span class="n">VirtualProtectEx</span>
    <span class="p">(</span>
        <span class="n">hProcess</span><span class="p">,</span>
        <span class="n">lpBaseAddress</span><span class="p">,</span>
        <span class="n">nSize</span><span class="p">,</span>
        <span class="n">oldProtect</span><span class="p">,</span>
        <span class="o">&amp;</span><span class="n">dummy</span>
    <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;VirtualProtectEx(RESTORING) in RetReadProcessMemory() failed with  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="/tag/c.html">C</a>
      <a href="/tag/hooking.html">Hooking</a>
      <a href="/tag/programming.html">Programming</a>
      <a href="/tag/security.html">Security</a>
      <a href="/tag/windows.html">Windows</a>
      <a href="/tag/nt.html">Nt</a>
      <a href="/tag/assembler.html">Assembler</a>
      <a href="/tag/iat.html">Iat</a>
    </p>
  </div>
</article>

    <footer>
      <p>&copy; Nikolai Tschacher 2015</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "IAT hooking",
  "headline": "IAT hooking",
  "datePublished": "2013-12-07 11:37:00+01:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Nikolai Tschacher",
    "url": "/author/nikolai-tschacher.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "/iat-hooking.html",
  "description": "What I just rummaged through my old hard disk and suddenly stumbled across some old C sources from around a year ago when I played with IAT hooking on windows 7. I will not explain much, but I made the bottom code around a year ago (Thus, in 2012) and ..."
}
</script></body>
</html>