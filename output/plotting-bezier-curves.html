<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="/theme/css/style.min.css">
  <link rel="stylesheet" type="text/css" href="/theme/css/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="/theme/css/font-awesome.min.css">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />
<meta name="author" content="Nikolai Tschacher" />
<meta name="description" content="Last major Update: 21.10.2013 Github repo that contains the presented code in this post. Introduction In this article I will present you a very simple and in no sense optimized algorithm written in Python 3 that plots quadratic and cubic Bézier curves. I'll implement several variants of ..." />
<meta name="keywords" content="Font, Captcha, Programming, Mathematics, Learning, Bézier">
<meta property="og:site_name" content="Coding, Learning and IT Security"/>
<meta property="og:title" content="Plotting Bézier curves directly and with De Casteljau's algorithm"/>
<meta property="og:description" content="Last major Update: 21.10.2013 Github repo that contains the presented code in this post. Introduction In this article I will present you a very simple and in no sense optimized algorithm written in Python 3 that plots quadratic and cubic Bézier curves. I'll implement several variants of ..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="/plotting-bezier-curves.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2013-10-06 23:23:00+02:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="/author/nikolai-tschacher.html">
<meta property="article:section" content="Learning"/>
<meta property="article:tag" content="Font"/>
<meta property="article:tag" content="Captcha"/>
<meta property="article:tag" content="Programming"/>
<meta property="article:tag" content="Mathematics"/>
<meta property="article:tag" content="Learning"/>
<meta property="article:tag" content="Bézier"/>
<meta property="og:image" content="">  <title>Coding, Learning and IT Security &ndash; Plotting Bézier curves directly and with De Casteljau's algorithm</title>
</head>
<body>
  <aside>
    <div>
      <a href="">
        <img src="/theme/img/profile.png" alt="Coding, Learning and IT Security" title="Coding, Learning and IT Security">
      </a>
      <h1><a href="">Coding, Learning and IT Security</a></h1>
      <p></p>
      <nav>
        <ul class="list">
          <li><a href="/pages/about.html#about">About</a></li>
          <li><a href="/pages/contact.html#contact">Contact</a></li>
          <li><a href="/pages/googlescraper-py.html#googlescraper-py">GoogleScraper.py</a></li>
          <li><a href="/pages/projects.html#projects">Projects</a></li>
          <li><a href="/pages/impressum.html#impressum">Site Notice</a></li>
          <li><a href="/pages/svgcaptcha.html#svgcaptcha">SVGCaptcha</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-twitter" href="https://twitter.com/incolumitas_" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-github" href="https://github.com/NikolaiT" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-rss" href="//incolumitas/feeds/all.atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
        <li><a class="sc-stack-overflow" href="http://stackoverflow.com/users/1052496/nikolai-tschacher" target="_blank"><i class="fa fa-stack-overflow"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
    </nav>

<article>
  <header>
    <h1 id="plotting-bezier-curves">Plotting Bézier curves directly and with De Casteljau's algorithm</h1>
    <p>Posted on So 06 Oktober 2013 in <a href="/category/learning.html">Learning</a></p>
  </header>
  <div>
    <p><em>Last major Update: 21.10.2013</em>  </p>
<p><a href="https://github.com/NikolaiT/CunningCaptcha/tree/master/python_tests">Github repo that contains the presented code in this
post.</a></p>
<h3>Introduction</h3>
<p>In this article I will present you a very simple and in no sense
optimized algorithm written in Python 3 that plots quadratic and cubic
Bézier curves. I'll implement several variants of Bézier rasterization
algorithms. Let's call the first version the direct approach, since it
computes the corresponding x and y coordinates directly by evaluation of
the equation that describes such Bézier curvatures.  </p>
<p>The other possibility is De Casteljau's algorithm, a recursive
implementation. The general principle is illustrated
<a href="http://en.wikipedia.org/wiki/De_Casteljau's_algorithm#Geometric_interpretation">here</a>.
But the summarize the idea very briefly: In order to compute the points
of the Bézier curve, you subdivide the lines of the outer hull that are
given from the n+1 control points [Where n denotes the dimension of the
Bézier curve) at a ratio t (t goes from 0 to 1 in a loop). If you
connect the interpolation points, you'll obtain n-1 connected lines.
Then you apply the exactly same principle to these newly obtained lines
as before (recursive step), until you finally get one line remaining.
Consider again the point at the ratio t on this single line left and
BOOM you got your point on the Bézier curve for your specific t value.
Increase t and continue this process until you plotted the curve
(Graphic equivalent of the description see below. I don't own the image,
the source is: http://wiki.ece.cmu.edu)<br />
<img alt="Casteljau
Principle" src="http://wiki.ece.cmu.edu/ddl/images/DeCasteljau2.png" /><br />
In this article, I'll supply source code snippets for both algorithms
mentioned above and will add a simple performance test to compare them.
Additionally, I am going to polish the direct approach for performance
and will depict some recipes I learned from other blogs to increase the
efficiency of the plotting algorithm.</p>
<h3>Background. Splines, What for?</h3>
<p>But why do I even need such geometrical primitives? I am currently
working on my captcha wordpress plugin, which builds the captcha from
the ground up and therefore needs some mechanism to rasterize
geometrical figures such as characters (Yes for once I am talking of
<em>those</em>, not the data type\^\^). Thus I need three different shapes:
Simple lines, circles (or more generally ellipses) and lastly Bézier
curves. I could compose rudimentary characters just with lines and
circles but we do have some ambition over here, don't we? :)</p>
<p>This means that I will essentially define a new, but very primitive
font. I guess that my font will contain around 10 to 15 glyphs and it
will use a mezcla (mix) of bitmap and outline fonts techniques. If you
want to know more about them, just <a href="http://en.wikipedia.org/wiki/Computer_font#Font_types">read
it up</a><a href="http://en.wikipedia.org/wiki/Computer_font#Font_types">.</a>
I am also going to publish a separate post blog about this font project
in the near future, so stay tuned (<strong>Edit:</strong> <a href="http://incolumitas.com/2013/10/16/create-your-own-font-the-hard-way/">The future has
arrived</a>.
I am really excited about how ugly and cruel this font is going to be
(Actually that's even an advantage for CAPTCHAS).</p>
<p>If you are further interested in the technical background knowledge and
mathematical properties of Bézier splines, consider reading the
<a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve">Wikipedia article</a> or
<a href="http://pomax.github.io/bezierinfo/">this wonderful tutorial</a> and then
there's also <a href="http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-11-rendering-the-teapot-bezier-surfaces/">this nice
introduction</a>.
The authors of those articles explain the concepts ways better than a
layman as I ever could. Here, I just present some simple code snippets
to get started and wet the appetite, as well as a discussion of
performance issues.</p>
<p>Finally we get to see some actual code. This python script essentially
draws quadratic and cubic Bézier curves. That's the direct approach as
stated above. Note that the code is yet horribly unoptimized.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">tkinter</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Bezier</span><span class="p">(</span><span class="n">tkinter</span><span class="o">.</span><span class="n">Canvas</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Simple and slow algorithm to draw quadratic and </span>
<span class="sd">    cubic Bézier curves. Heavily inspired by http://pomax.github.io/bezierinfo/#control</span>
<span class="sd">    This code should just prove a concept and is not intended to be </span>
<span class="sd">    used in a real world app...</span>
<span class="sd">    Author: Nikolai Tschacher</span>
<span class="sd">    Date: 07.10.2013</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c"># Because Canvas doesn&#39;t support simple pixel plotting,</span>
    <span class="c"># we need to help us out with a line with length 1 in</span>
    <span class="c"># positive x direction.</span>
    <span class="k">def</span> <span class="nf">plot_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_line</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>

    <span class="c"># Calculates the quadtratic Bézier polynomial for </span>
    <span class="c"># the n+1=3 coordinates.</span>
    <span class="k">def</span> <span class="nf">quadratic_bezier_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span> 
        <span class="n">mt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">t</span>
        <span class="n">mt2</span> <span class="o">=</span> <span class="n">mt</span> <span class="o">*</span> <span class="n">mt</span>
        <span class="k">return</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">mt2</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">mt</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">t2</span>

    <span class="c"># Calculates the cubic Bézier polynomial for </span>
    <span class="c"># the n+1=4 coordinates.</span>
    <span class="k">def</span> <span class="nf">cubic_bezier_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">*</span> <span class="n">t</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">t</span>
        <span class="n">mt2</span> <span class="o">=</span> <span class="n">mt</span> <span class="o">*</span> <span class="n">mt</span>
        <span class="n">mt3</span> <span class="o">=</span> <span class="n">mt2</span> <span class="o">*</span> <span class="n">mt</span>
        <span class="k">return</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">mt3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">mt2</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">mt</span><span class="o">*</span><span class="n">t2</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">t3</span>

    <span class="k">def</span> <span class="nf">draw_quadratic_bez</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_bezier_sum</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p3</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_bezier_sum</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p3</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c"># self.plot_pixel(math.floor(x), math.floor(y))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_pixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="mf">0.001</span> <span class="c"># 1000 iterations. If you want the curve to be really</span>
                       <span class="c"># fine grained, consider &quot;t += 0.0001&quot; for ten thousand iterations.</span>

    <span class="k">def</span> <span class="nf">draw_cubic_bez</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cubic_bezier_sum</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p3</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p4</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cubic_bezier_sum</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p4</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_pixel</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="mf">0.001</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">master</span> <span class="o">=</span> <span class="n">tkinter</span><span class="o">.</span><span class="n">Tk</span><span class="p">()</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">Bezier</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="n">w</span><span class="o">.</span><span class="n">pack</span><span class="p">()</span>

    <span class="c"># Finally draw some Bézier curves :)</span>
    <span class="c">#w.draw_quadratic_bez((70, 250), (62, 59), (250, 61))</span>
    <span class="c">#w.draw_quadratic_bez((170,77), (162, 159), (210, 161))</span>
    <span class="n">w</span><span class="o">.</span><span class="n">draw_quadratic_bez</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">162</span><span class="p">,</span> <span class="mi">89</span><span class="p">),</span> <span class="p">(</span><span class="mi">250</span><span class="p">,</span> <span class="mi">61</span><span class="p">))</span>
    <span class="c">#w.draw_cubic_bez((120, 160), (35, 200), (153, 268), (165, 70))</span>
    <span class="n">tkinter</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span>
</pre></div>


<p>And now De Casteljau’s algorithm. It's not limited to quadratic and
cubic Bézier curves, on the contrary, you are free to plot curves of any
degree n. Just give it a try!</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">tkinter</span>

<span class="k">class</span> <span class="nc">InvalidInputError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Casteljau</span><span class="p">(</span><span class="n">tkinter</span><span class="o">.</span><span class="n">Canvas</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Implementation of de Casteljau&#39;s algorithm for drawing Bézier curves.</span>
<span class="sd">    Implemented along the submittal of http://pomax.github.io/bezierinfo/#control.</span>
<span class="sd">    Author: Nikolai Tschacher</span>
<span class="sd">    Date: 07.10.2013</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c"># Because Canvas doesn&#39;t support simple pixel plotting,</span>
    <span class="c"># we need to help us out with a line with length 1 in</span>
    <span class="c"># positive x direction.</span>
    <span class="k">def</span> <span class="nf">plot_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_line</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">draw_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="c"># Check that input parameters are valid. We don&#39;t check wheter </span>
        <span class="c"># the elements in the tuples are of type int or float.</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span><span class="s">&#39;points is not a list of points(tuples)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_pixel</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newpoints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">newpoints</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">draw_curve</span><span class="p">(</span><span class="n">newpoints</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="c"># Use De Casteljau&#39;s algorithm with recursion eliminated, but the same</span>
    <span class="c"># geometrical approach. Idea: Eliminate the expensive stack frame generation</span>
    <span class="c"># that recursion comes with. Only quadratical Bézier curves.</span>
    <span class="k">def</span> <span class="nf">draw_point2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="c"># Vector addition of P0+P1</span>
        <span class="n">q0_x</span><span class="p">,</span> <span class="n">q0_y</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">q1_x</span><span class="p">,</span> <span class="n">q1_y</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">b_x</span><span class="p">,</span> <span class="n">b_y</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">q0_x</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">q1_x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">q0_y</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">q1_y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_pixel</span><span class="p">(</span><span class="n">b_x</span><span class="p">,</span> <span class="n">b_y</span><span class="p">)</span>

    <span class="c"># Usage function for the algorithm.</span>
    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">draw_curve</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="mf">0.001</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">master</span> <span class="o">=</span> <span class="n">tkinter</span><span class="o">.</span><span class="n">Tk</span><span class="p">()</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">Casteljau</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
    <span class="n">w</span><span class="o">.</span><span class="n">pack</span><span class="p">()</span>

    <span class="c"># Finally draw some Bézier curves :)</span>
    <span class="n">w</span><span class="o">.</span><span class="n">draw</span><span class="p">([(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">250</span><span class="p">),</span> <span class="p">(</span><span class="mi">462</span><span class="p">,</span> <span class="mi">159</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
    <span class="c">#w.draw([(133, 267), (121, 28), (198, 270), (210, 29)])</span>
    <span class="n">tkinter</span><span class="o">.</span><span class="n">mainloop</span><span class="p">()</span>
</pre></div>


<p>And finally the performance comparison between the two algorithms. The
direct approach wins over De Casteljau’s algorithm (I guess because
recursion is such a slowpoke), but on the other side, De Casteljau's
method is numerically stable. The direct approach is a little more than
twice as fast (This might not be accurate, since Python isn't really the
language you use for such stuff and additionally my implementation is
certainly not good enough such that I can say that any De Casteljau
algorithm implementation is exactly twice as slow as the direct
approach. These comparisons are rather a rough estimation)! Note that
the initial type checks in draw_curve() in class Casteljau were
disabled while testing the speed to avoid contortions. Furthermore, I've
shamelessly stolen the timing method from <a href="http://preshing.com/20110924/timing-your-code-using-pythons-with-statement/">this
site</a>,
using the following little class to time within <em>with</em> statements:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>

<span class="k">class</span> <span class="nc">Timer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">secs</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="c"># millisecs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;[!] </span><span class="si">%s</span><span class="s"> - elapsed time: </span><span class="si">%f</span><span class="s"> ms&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msecs</span><span class="p">))</span>
</pre></div>


<p>Eventually the source code for the performance tests. Please consider
that it might be hard to reproduce the exact same results as below,
since the code in the github repo evolves over time:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">timer</span> <span class="kn">import</span> <span class="n">Timer</span>
<span class="kn">from</span> <span class="nn">bezier</span> <span class="kn">import</span> <span class="n">Bezier</span> <span class="c"># Simple bezier drawing algorithm directly derived from calculus.</span>
<span class="kn">from</span> <span class="nn">casteljau</span> <span class="kn">import</span> <span class="n">Casteljau</span> <span class="c"># Drawing curves using de Casteljau&#39;s algorithm.</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="c"># Overwrite Bezier class and Casteljau class to disable the GUI functions. We just want to </span>
<span class="c"># mesure the algorithm&#39;s performance not the graphical toolkit overhead...</span>

<span class="c"># Pre calculate random points for quadratic and cubic Bézier simulation for</span>
<span class="c"># performance tests.</span>
<span class="n">NUMBER_OF_CURVES</span> <span class="o">=</span> <span class="mi">500</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randrange</span>
<span class="n">pp</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">)),</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">)),</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">))]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUMBER_OF_CURVES</span><span class="p">)]</span>
<span class="n">pp4</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">)),</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">)),</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">)),</span> <span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="n">R</span><span class="p">(</span><span class="mi">500</span><span class="p">))]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUMBER_OF_CURVES</span><span class="p">)]</span>

<span class="k">class</span> <span class="nc">BezierPerf</span><span class="p">(</span><span class="n">Bezier</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test1</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test2</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">plot_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="k">pass</span> <span class="c"># Nothin here oO</span>
    <span class="k">def</span> <span class="nf">test1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s">&#39;Testing quadratic bezier with direct approach&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">pp</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">draw_quadratic_bez</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">test2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s">&#39;Testing cubic curves with direct approach&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">pp4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">draw_cubic_bez</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">CasteljauPerf</span><span class="p">(</span><span class="n">Casteljau</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test1</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test2</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">plot_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="k">pass</span> <span class="c"># No drawing please.</span>
    <span class="k">def</span> <span class="nf">test1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s">&#39;Testing quadratic bezier curves with De Casteljau&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">pp</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">test2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">Timer</span><span class="p">(</span><span class="s">&#39;Testing cubic bezier curves with De Casteljau&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">points</span> <span class="ow">in</span> <span class="n">pp4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">test2</span> <span class="o">=</span> <span class="n">CasteljauPerf</span><span class="p">()</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">BezierPerf</span><span class="p">()</span>
</pre></div>


<p>The above timing yields this output:  </p>
<p><code>[nikolai@niko-arch python_tests]$ python performance_tests.py [!] Testing quadratic bezier curves with De Casteljau - elapsed time: 5814.155579 ms [!] Testing cubic bezier curves with De Casteljau - elapsed time: 9396.822453 ms [!] Testing quadratic bezier with direct approach - elapsed time: 1528.661489 ms [!] Testing cubic curves with direct approach - elapsed time: 2135.466337 ms</code></p>
<h3>Optimizing</h3>
<p>When it comes to optimization, one can go almost infinitely deep and
far. There's a huge amount of scientific research and work invested,
because saving CPU power means saving money. For instance, in compiler
development, the optimization part constitutes the most complex and
work-intense part (If I remember my coursera lessons correctly). I
instead will only scratch on the surface and won't dive into the depths
of optimizing (Well these metaphors combined is utterly strange ;))<br />
I will tune the direct algorithm, because it is just faster then De
Casteljau's recursive approach.</p>
<p>Some concepts (and common sense):</p>
<ul>
<li><em>Avoid double calculations.</em> Have a look at the Code above (or <a href="https://github.com/NikolaiT/CunningCaptcha/blob/master/python_tests/bezier.py">on
    github</a>).
    The functions <code>quadratic_bezier_sum</code> and <code>cubic_bezier_sum</code> are
    called twice for the x and the y coordinate. But this means that the
    coefficients of the equation are also calculated twice, although we
    could just compute them once and reuse them for the other
    coordinates (In our case just for the y coordinate). Eliminate this
    problem through incorporating the function's logic directly into the
    calle's context, namely into the methods
    <code>draw_(quadratic|cubic)_bezier_sum</code>. This brings us directly to the
    second point...</li>
<li>
<p><em>Spare on function calls.</em> Function calls are a nice way to separate
    concepts logically and organize your code (structural/imperative
    programming) but you should't use them excessively in time critical
    code. But why? Function calls mean new call stacks. And each
    operation in the ram/stack is at least 100 times slower than using
    CPU registers directly. This is also the reason why recursion is so
    inefficient (Recursion=many many stack frames). To readopt the
    example above: When we integrate the functions
    quadratic_bezier_sum and <code>cubic_bezier_sum</code> into the calling
    functions we eliminate exactly 1000 functions calls (Assuming we
    increase the parameter t in each loop by 0.001). Further, this means
    we spare 500'000 function calls when we draw 500 splines. So
    remember: Don't implement too many function calls inside the body of
    the loops. You can examine the updated function called
    <code>_draw_(quadratic|cubic)_bez</code> on github
    <a href="https://github.com/NikolaiT/CunningCaptcha/blob/master/python_tests/geoprim.py">here</a>
    The preliminary and this aspect together brings us the following
    performance boost over the inefficient code at the start of this
    post:  </p>
<p><code>[+] Testing task is to draw 500 randomly generated Bézier splines with different algorithms. Approximation uses 20 segments. [!] Testing unoptimized quadratic bezier with direct approach - elapsed time: 2512.458563 ms [!] Testing unoptimized cubic curves with direct approach - elapsed time: 3192.077160 ms [!] Testing quadratic bezier curves with direct approach - elapsed time: 2277.250528 ms [!] Testing cubic bezier curves with direct approach - elapsed time: 2857.527494 ms</code><br />
That's after all a 11% performance increase! Not bad for a start :)
-   <em>Be aware of multiplications/divisions.</em>The more operations you can
eliminate, the better. Usually, multiplications are slower than
additions, so you might try to algebraically simplify your
calculations of find other ways to use less arithmetic operations.
In my case there would be a technique called fast forward
differencing with using Taylor series. This technique is especially
nice when you want to speedup the rasterization of big, complex
splines but diminishes when you need to draw many comparable simple
curves, as I do in my font project. Therefore I won't make use of
it. However, if you want to learn it, <a href="http://scratchapixel.com/lessons/3d-basic-lessons/lesson-11-rendering-the-teapot-bezier-surfaces/fast-forward-differencing/">here you
go.</a>
-   <em>Precalculate stuff</em> Just use look-up tables. Especially in my case,
look-up tables will help to speed up the algorithms a great deal.
This means, I will precompute all coefficients for the Bézier
splines (3 coefficients in case of quadratic splines, 4 in case of
cubic curves). Suppose I am going too draw 500 cubic Bézier curves,
and each curve consists of 1000 points. Accordingly the algorithm
will calculate a matrix of 1000 entries and each entry consists of
the 4 coefficients (3 respectively when plotting quadratic splines).
That's around <code>4*8*1000=32kb</code> of data of RAM too hold all possible
coefficients, not really much on a average 6-8 GB built-in RAM
nowadays ;). Here is the relevant code excerpt that shows the
generation of the look-up table:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_quadratic_bez_lut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LUT_Q</span><span class="p">:</span>
        <span class="c">#print(&#39;[i] lut generating for quadratic splines...&#39;)</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">t</span>
            <span class="n">mt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">t</span>
            <span class="n">mt2</span> <span class="o">=</span> <span class="n">mt</span><span class="o">*</span><span class="n">mt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_LUT_Q</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mt2</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">mt</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_STEP</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LUT_Q</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p3</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p3</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_pixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_cubic_bez_lut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LUT_C</span><span class="p">:</span>
        <span class="c">#print(&#39;[i] lut generating for cubic splines...&#39;)</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">t</span>
            <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span><span class="o">*</span><span class="n">t</span>
            <span class="n">mt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">t</span>
            <span class="n">mt2</span> <span class="o">=</span> <span class="n">mt</span><span class="o">*</span><span class="n">mt</span>
            <span class="n">mt3</span> <span class="o">=</span> <span class="n">mt2</span><span class="o">*</span><span class="n">mt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_LUT_C</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mt3</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">mt2</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">mt</span><span class="o">*</span><span class="n">t2</span><span class="p">,</span> <span class="n">t3</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_STEP</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LUT_C</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p3</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">p4</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">p3</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">p4</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_pixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>


<p>.<br />
And here you see the performance results:  </p>
<p><code>[+] Testing task is to draw 500 randomly generated Bézier splines with different algorithms. Approximation uses 20 segments. [!] Testing quadratic bezier curves with direct approach - elapsed time: 2320.041656 ms [!] Testing cubic bezier curves with direct approach - elapsed time: 2830.367804 ms [!] Testing quadratic bezier curves with lookup tables - elapsed time: 1840.610504 ms [!] Testing cubic bezier curves with lookup tables - elapsed time: 2220.727682 ms</code><br />
This means we get another 30% performance boost (quadratic and
cubic computations scale linearly percent wise)! Honestly, I
expected more of using look-up tables. Please leave a comment in
case I implemented them wrong.</p>
</li>
<li>
<p><em>Approximate</em> Why even calculating 1000 Points? Usually you can't
    even appreciate the smoothness of such a curve, because the splines
    are just not big enough in the end (For instance in the final
    captcha), performance however is always good to have ;) That being
    said, I will proceed as follows: Instead of iterating 1000 times, I
    will simply iterate 15 times and thus evaluate the Bézier equation
    only 15 times. Then I will just connect these 15 points with
    straight lines. Let's see how fast all the previous techniques and
    this combined will make the algorithm (Note that the precalculating
    trick and the approximation intersect performance wise, because now
    the look-up table is not anywhere as useful as before, since we
    evaluate the equation only 15 times). Here's the updated code
    together with the final performance results. First the approximation
    code:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_approx_quadratic_bez</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">):</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NUM_SEGMENTS</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NUM_SEGMENTS</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">t</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">t</span>
        <span class="n">mt2</span> <span class="o">=</span> <span class="n">mt</span><span class="o">*</span><span class="n">mt</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">mt2</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">mt</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">p3</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">t2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">mt2</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">mt</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">p3</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">t2</span><span class="p">)</span>
        <span class="n">lp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">([</span><span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>

<span class="k">def</span> <span class="nf">_approx_cubic_bez</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">):</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_NUM_SEGMENTS</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_NUM_SEGMENTS</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">t</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">*</span> <span class="n">t</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">t</span>
        <span class="n">mt2</span> <span class="o">=</span> <span class="n">mt</span> <span class="o">*</span> <span class="n">mt</span>
        <span class="n">mt3</span> <span class="o">=</span> <span class="n">mt2</span> <span class="o">*</span> <span class="n">mt</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">mt3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">mt2</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">p3</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">mt</span><span class="o">*</span><span class="n">t2</span> <span class="o">+</span> <span class="n">p4</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">t3</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">mt3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">mt2</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">p3</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">mt</span><span class="o">*</span><span class="n">t2</span> <span class="o">+</span> <span class="n">p4</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span>
        <span class="n">lp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">([</span><span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>


<p>And now all performance results together:  </p>
<p><code>[+] Testing task is to draw 500 randomly generated Bézier splines with different algorithms. Approximation uses 20 segments. [!] Testing quadratic bezier curves with De Casteljaus algorithm - elapsed time: 7362.981081 ms [!] Testing cubic bezier curves with De Casteljaus algorithm - elapsed time: 11826.589823 ms [!] Testing unoptimized quadratic bezier with direct approach - elapsed time: 2533.061028 ms [!] Testing unoptimized cubic curves with direct approach - elapsed time: 3126.898527 ms [!] Testing quadratic bezier curves with direct approach - elapsed time: 2231.390953 ms [!] Testing cubic bezier curves with direct approach - elapsed time: 2773.490906 ms [!] Testing quadratic bezier curves with lookup tables - elapsed time: 1845.245123 ms [!] Testing cubic bezier curves with lookup tables - elapsed time: 2269.758940 ms [!] Testing quadratic bezier curves with approximation - elapsed time: 252.831936 ms [!] Testing cubic bezier curves with approximation - elapsed time: 286.973476 ms</code><br />
BOOM! The approximation needs stunning 287 milliseconds to plot 500
random cubic Bézier splines, whereas De Casteljaus algorithm takes
12 Seconds! That's 42 times faster! You say the approximation looks
ugly? Maybe your right, but for my purposes it's certainly enough.
Here's a picture of a spline plotted with the approximation method
(on the left) and De Casteljau's algorithm (on the right). In my
opinion there is no big difference (From this perspective, and for
the captcha purposes it is really enough resolution).<br />
[<img alt="Comparison" src="/uploads/2013/10/approx_vs_castel-1024x576.png" />
Both splines are identical. On the left is the curve approximated
(fast) and on the right drawn with De Casteljau's algorithm
(slow).</p>
<p>[<img alt="Comparison of De Casteljau's algorithm and the
approximative
method," src="/uploads/2013/10/approx_vs_casteljau2-1024x576.png" /></p>
<p>Both splines are exactly the same. On the left is the curve
approximated by lines (fast) and on the right drawn with De
Casteljau's algorithm (slow).</p>
</li>
</ul>
<h3>Conclusion</h3>
<p>We saw some performance boosting techniques. From initial 7,3 seconds
with De Casteljaus algorithm (plotting 500 quadratic splines) , we made
it down to 0.252 seconds! That's around 40 times faster. Of course we
could be better, but let's stop here!</p>
<h3>Drawing Lines</h3>
<p>That's almost it! We also need a algorithm for plotting staright lines.
Maybe you think that's a trivial task, but not so fast my dear. There's
actually <a href="http://en.wikipedia.org/wiki/Bresenham's_line_algorithm">quite a bit of
math</a> behind
simple even lines! I adopted the algorithm from <a href="http://members.chello.at/easyfilter/bresenham.html">this
site</a>, which offers
also a 100 page strong essay about plotting geometrical primitives. The
text is quite hard to understand if you don't possess profound
mathematical knowledge, but it's still worth a glimpse!</p>
<p>However, this is the line plotting algorithm:</p>
<div class="highlight"><pre><span class="c"># Yet another implementation taken from</span>
<span class="c"># http://members.chello.at/easyfilter/bresenham.html</span>
<span class="c"># This alogrithm is capable to plot all possible lines in a 2d plane.</span>
<span class="k">def</span> <span class="nf">line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span><span class="s">&#39;To draw a line we need a list of two tuples containing two ints&#39;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="n">points</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y0</span><span class="p">)</span>
    <span class="n">sx</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">][</span><span class="n">x0</span><span class="o">=</span> <span class="n">dy</span><span class="p">):</span>
            <span class="n">err</span> <span class="o">+=</span> <span class="n">dy</span>
            <span class="n">x0</span> <span class="o">+=</span> <span class="n">sx</span>     
        <span class="k">if</span> <span class="p">(</span><span class="n">e2</span> <span class="o">&lt;=</span> <span class="n">dx</span><span class="p">):</span>
            <span class="n">err</span> <span class="o">+=</span> <span class="n">dx</span>
            <span class="n">y0</span> <span class="o">+=</span> <span class="n">sy</span>
</pre></div>


<p>I have shown you some rasterization algorithms and now I am ready to use
them to draw my font. In the next article, I will use this code! So stay
tuned and send me a letter for Christmas!
s!</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="/tag/font.html">Font</a>
      <a href="/tag/captcha.html">Captcha</a>
      <a href="/tag/programming.html">Programming</a>
      <a href="/tag/mathematics.html">Mathematics</a>
      <a href="/tag/learning.html">Learning</a>
      <a href="/tag/bezier.html">Bézier</a>
    </p>
  </div>
</article>

    <footer>
      <p>&copy; Nikolai Tschacher 2015</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Plotting Bézier curves directly and with De Casteljau's algorithm",
  "headline": "Plotting Bézier curves directly and with De Casteljau's algorithm",
  "datePublished": "2013-10-06 23:23:00+02:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Nikolai Tschacher",
    "url": "/author/nikolai-tschacher.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "/plotting-bezier-curves.html",
  "description": "Last major Update: 21.10.2013 Github repo that contains the presented code in this post. Introduction In this article I will present you a very simple and in no sense optimized algorithm written in Python 3 that plots quadratic and cubic Bézier curves. I'll implement several variants of ..."
}
</script></body>
</html>